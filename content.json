{"meta":{"title":"lzh","subtitle":"简单生活","description":"lzh的个人博客,主要为记录","author":"lizehong","url":"http://lizehongss.github.io/newBlog","root":"/newBlog/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-07-25T13:43:10.968Z","updated":"2020-07-25T13:43:10.968Z","comments":false,"path":"/404.html","permalink":"http://lizehongss.github.io/newBlog/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-07-25T13:43:10.968Z","updated":"2020-07-25T13:43:10.968Z","comments":false,"path":"about/index.html","permalink":"http://lizehongss.github.io/newBlog/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2020-07-25T13:43:10.968Z","updated":"2020-07-25T13:43:10.968Z","comments":false,"path":"books/index.html","permalink":"http://lizehongss.github.io/newBlog/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-07-25T13:43:10.968Z","updated":"2020-07-25T13:43:10.968Z","comments":false,"path":"categories/index.html","permalink":"http://lizehongss.github.io/newBlog/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-07-25T13:43:10.968Z","updated":"2020-07-25T13:43:10.968Z","comments":true,"path":"links/index.html","permalink":"http://lizehongss.github.io/newBlog/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-07-25T13:43:10.968Z","updated":"2020-07-25T13:43:10.968Z","comments":false,"path":"repository/index.html","permalink":"http://lizehongss.github.io/newBlog/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-07-25T13:43:10.968Z","updated":"2020-07-25T13:43:10.968Z","comments":false,"path":"tags/index.html","permalink":"http://lizehongss.github.io/newBlog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"element源码样式学习","slug":"element源码样式学习","date":"2020-04-20T00:00:00.000Z","updated":"2020-07-25T13:43:10.968Z","comments":true,"path":"2020/04/20/element源码样式学习/","link":"","permalink":"http://lizehongss.github.io/newBlog/2020/04/20/element%E6%BA%90%E7%A0%81%E6%A0%B7%E5%BC%8F%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"element源码样式学习目录结构element的样式存放在element的packages/theme-chalk中,目录结构如下所示: 123456789101112131415161718192021222324252627282930313233343536373839│ alert.scss &#x2F;&#x2F;组件样式│ aside.scss│ autocomplete.scss│ avatar.scss│ backtop.scss│ badge.scss│ base.scss│ breadcrumb-item.scss│ breadcrumb.scss│ button-group.scss│ button.scss| &#x2F;&#x2F; 省略部分组件样式├─common &#x2F;&#x2F; 组件共用样式│ popup.scss &#x2F;&#x2F;弹层类组件共用样式│ transition.scss &#x2F;&#x2F;主要定义了element组件中使用vue的 transition 组件时用到的动态效果样式│ var.scss &#x2F;&#x2F; 定义了element各组件UI的基本样式的变量,包括颜色,文本大小,边框大小,组件不同尺寸对应的不同样式│ ├─date-picker &#x2F;&#x2F; date组件使用样式│ date-picker.scss│ date-range-picker.scss│ date-table.scss│ month-table.scss│ picker-panel.scss│ picker.scss│ time-picker.scss│ time-range-picker.scss│ time-spinner.scss│ year-table.scss│ ├─fonts &#x2F;&#x2F; 字体文件│ element-icons.ttf│ element-icons.woff│ └─mixins &#x2F;&#x2F; scss复用函数 config.scss &#x2F;&#x2F; 样式名的全局配置 function.scss &#x2F;&#x2F; 组件样式使用到的sccss函数 mixins.scss &#x2F;&#x2F; 共用的mixins函数 utils.scss &#x2F;&#x2F; 工具类函数样式, 如禁用用户选择 _button.scss &#x2F;&#x2F; 按钮基本样式 主要文件分析config.scssconfig.scss 文件定义了element样式的全局配置,如样式名前缀,,样式名分割符等 123456// 这四个样式名配置是element所有样式名定义的基础// 如: el-button, el-select, is-disabled等样式名$namespace: 'el';$element-separator: '__';$modifier-separator: '--';$state-prefix: 'is-'; mixins.scssmixins.scss 文件定义了element各组件样式使用的基本mixins,这里对最主要的mixinx做分析 @mixin b() 混入el 123456789@mixin b($block) &#123; &#x2F;&#x2F; 假如 $block为button $B: $namespace+&#39;-&#39;+$block !global; $namespace在config.scss中定义为el,故$B为el-blutton .#&#123;$B&#125; &#123; &#x2F;&#x2F; .#&#123;&#125; 为scss变量插值,编译后为.el-button @content; &#125;&#125;&#x2F;&#x2F; @content&#96;用在mixin里面的，当定义一个mixin后，并且设置了@content&#x2F;&#x2F; @include的时候可以传入相应的内容到mixin里面 @mixin e() 混入__ 12345678910111213141516171819202122232425262728293031323334@mixin e($element) &#123; /**假设$element为disabled **/ $E: $element !global; $selector: &amp;; // 父选择器 $currentSelector: \"\"; // 要生成的选择器 /** 遍历$element //可能有多个 /* $B 为 mixin b()混入中的变量名 /* 这里使用$B是因为在element组件样式中e的混入必定是在b混入下的 /* 如果是在el-button下使用e混入,则生成 .el-button__disabked **/ @each $unit in $element &#123; $currentSelector: #&#123;$currentSelector + \".\" + $B + $element-separator + $unit + \",\"&#125;; &#125; /** hitAllSpecialNestRule 判断$elector是否包含--, is-, 在function.scc 中定义 /* 这里判断是否包含is--,--是因为使用了 @at-root /* @at-root指令可以使一个或多个规则被限定输出在文档的根层级上，而不是被嵌套在其父选择器下 /* 包含有is--等前缀的样式名,在组件中一般是可移除的,所以在输出在文档的根层级上时要加上父选择器 **/ @if hitAllSpecialNestRule($selector) &#123; @at-root &#123; #&#123;$selector&#125; &#123; #&#123;$currentSelector&#125; &#123; @content; &#125; &#125; &#125; &#125; @else &#123; @at-root &#123; #&#123;$currentSelector&#125; &#123; @content; &#125; &#125; &#125;&#125; @mixin m() 混入– 123456789101112131415161718/** /* 该方法与混入e基本相同,不同的是没有判断hitAllSpecialNestRule/* 因为混入 -- 一般的是组件的尺寸样式,如 el-radio--medium,el-radio--small等,父选择器一般为el-radio等,/* 故不需要判断**/@mixin m($modifier) &#123; $selector: &amp;; $currentSelector: \"\"; @each $unit in $modifier &#123; $currentSelector: #&#123;$currentSelector + &amp; + $modifier-separator + $unit + \",\"&#125;; &#125; @at-root &#123; #&#123;$currentSelector&#125; &#123; @content; &#125; &#125;&#125; @mixin w() 混入 is 12345678910/** 假设$state为check/* 则编译后为在文档的根层级(在组件中使用时,为组件根样式)为.el-radio.is-checked**/@mixin when($state) &#123; @at-root &#123; &amp;.#&#123;$state-prefix + $state&#125; &#123; @content; &#125; &#125;&#125; functon.scssfunction.scss 主要是定义了 hitAllSpecialNestRule 函数方法，主要用来对选择器是否含有’is-‘, ‘–’, ‘:’主要代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@import \"config\";/* BEM support Func -------------------------- */@function selectorToString($selector) &#123; //字符化 $selector: inspect($selector); /** str-slice /* 从 $string 中截取子字符串，通过 $start-at 和 $end-at /* 设置始末位置，未指定结束索引值则默认截取到字符串末尾。 /* 这里主要是去除第一个字符和最后一个字符,避免如 --el, el：等的干扰 **/ $selector: str-slice($selector, 2, -2); @return $selector;&#125;@function containsModifier($selector) &#123; $selector: selectorToString($selector); /** str-index($string, $substring) /* 返回一个下标，标示 $substring 在 $string 中的起始位置。没有找到的话，则返回 null 值。 /* $modifier-specarator -- **/ @if str-index($selector, $modifier-separator) &#123; @return true; &#125; @else &#123; @return false; &#125;&#125;@function containWhenFlag($selector) &#123; $selector: selectorToString($selector);/** $state-prefix: 'is-'; **/ @if str-index($selector, '.' + $state-prefix) &#123; @return true &#125; @else &#123; @return false &#125;&#125;@function containPseudoClass($selector) &#123; $selector: selectorToString($selector); @if str-index($selector, ':') &#123; @return true &#125; @else &#123; @return false &#125;&#125;//** 对上述四种情况进行判断，有一种存在就返回true **/@function hitAllSpecialNestRule($selector) &#123; @return containsModifier($selector) or containWhenFlag($selector) or containPseudoClass($selector);&#125;","categories":[{"name":"源码学习","slug":"源码学习","permalink":"http://lizehongss.github.io/newBlog/categories/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"element","slug":"element","permalink":"http://lizehongss.github.io/newBlog/tags/element/"}]},{"title":"vue相关原理面试题整理","slug":"vue-interview","date":"2019-08-04T00:00:00.000Z","updated":"2020-07-25T13:43:10.968Z","comments":true,"path":"2019/08/04/vue-interview/","link":"","permalink":"http://lizehongss.github.io/newBlog/2019/08/04/vue-interview/","excerpt":"","text":"vue响应式原理实现主要通过Object.defineProperty实现，通过它对对象的属性进行getter和setter,从而实现访问和修改这个属性时，通过getter和setter实现依赖注入和派发更新。依赖注入和派发更新通过订阅-观察者模式实现，具体如下, 在访问属性时，通过getter给dep添加watcher类，setter时触发dep.notify()方法，使订阅了这个属性所实例化的dep的所有Watcher触发update方法 vue监测数组变化vue为了监测数组的变化，重新实现了Array的原型方法，包括push,prop等方法,重写的方法会执行本身原有的逻辑，对能增加数组本身长度的方法获取到插入的值，成一个响应式对象，并且再调用 ob.dep.notify() 手动触发依赖通知 nextTick实现原理在下次 DOM 更新循环结束之后执行延迟回调。nextTick主要使用了宏任务和微任务。根据执行环境分别尝试采用PromiseMutationObserversetImmediate如果以上都不行则采用setTimeout定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。 Vue的生命周期主要有created, mounted, updated, destory等， created时Vue实例并没有挂载，无法访问到组件的data,method，mountd是组件开始挂载能访问到data,method等数据,当组件DOM更新时触发update，组件销毁时触发destory computed和watchercomputed是计算属性，计算组件中data的值返回一个结果,当data的值改变时，计算属性的结果值也会改变wather用来监听data数据的变化 组件中的data为什么是一个函数一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。 v-model的原理v-model本质上是一个语法糖,当表单元素上使用时，实质上是分别定义了data数据和input事件 1&lt;input v-bind&#x3D;&quot;message&quot; v-on:input&#x3D;&quot;message &#x3D; $event.targe.value&quot; &gt; 在组件上使用时同上,不过事件input通过子组件$emit触发 1&lt;child :value&#x3D;&quot;message&quot; @input&#x3D;&quot;message&#x3D;arguments[0]&quot;&gt;&lt;&#x2F;child&gt; Vue事件绑定原理Vue事件绑定分为原生事件和自定义事件，原生事件本质上还是通过addEvent和removeEvent实现, 自定义事件，Vue会维护一个事件总线，当组件绑定自定义事件时，通过$on push到事件总线，当通过$emit调用时，在事件总线中查找并触发事件 ## Vue模版编译原理将Vue模板通过编译生成AST(一种用JavaScript对象的形式来描述整个模板),再对AST进行优化，主要是对数据不会改变的节点标记为静态节点，最后生成render函数 ## Vue2.x的diff算法diff算法主要判断vnode和oldVnode生成新的Vnode节点，主要过程如下:同级比较，再比较子节点先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)比较都有子节点的情况(核心diff)递归比较子节点Vue2的核心Diff算法采用了双端比较的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。相比React的Diff算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。 ## 虚拟Dom以及key属性在浏览器中对DOM操作是很昂贵的。频繁的操作DOM，会产生一定的性能问题，Virtual DOM本质就是用一个原生的JS对象去描述一个DOM节点。是对真实DOM的一层抽象。「key的作用是尽可能的复用 DOM 元素。」新旧 children 中的节点只有顺序是不同的时候，最佳的操作应该是通过移动元素的位置来达到更新的目的。需要在新旧 children 的节点中保存映射关系，以便能够在旧 children 的节点中找到可复用的节点。key也就是children中节点的唯一标识。 组件通信父子组件通过$parnet和$refs来访问数据，兄弟组件主要通过Vuex和实现一个 Event Bus 123var Event&#x3D;new Vue();Event.$emit(事件名,数据);Event.$on(事件名,data &#x3D;&gt; &#123;&#125;); ## hash路由和history路由实现原理hash模式的原理是 onhashchange 事件，可以在 window 对象上监听这个事件history实际采用了HTML5中提供的API来实现，主要有history.pushState()和history.replaceState()。","categories":[{"name":"面试","slug":"面试","permalink":"http://lizehongss.github.io/newBlog/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://lizehongss.github.io/newBlog/tags/vue/"}]},{"title":"vue-响应式原理","slug":"vue-响应式原理","date":"2019-05-15T00:00:00.000Z","updated":"2020-07-25T13:43:10.968Z","comments":true,"path":"2019/05/15/vue-响应式原理/","link":"","permalink":"http://lizehongss.github.io/newBlog/2019/05/15/vue-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/","excerpt":"","text":"vue初始化调用_init方法 -&gt; _init中会执行initState方法，对props,methods,data等属性初始化initProps()-&gt;调用deineReactive方法使其变成响应式initData()-&gt;调用observe方法使其变为响应式observe给对象添加getter和setter,用于依赖收集和派发更新 1234567891011121314151617181920212223242526272829303132333435export class Observer &#123; value: any; dep: Dep; vmCount: number; constructor (value: any) &#123; this.value &#x3D; value &#x2F;&#x2F; 实例化Dep对象，Dep是一个订阅者，用来存放Watcher观察者对象 this.dep &#x3D; new Dep() this.vmCount &#x3D; 0 &#x2F;&#x2F; 添加 this.__ob__ &#x3D; value def(value, &#39;__ob__&#39;, this) if (Array.isArray(value)) &#123; const augment &#x3D; hasProto ? protoAugment : copyAugment augment(value, arrayMethods, arrayKeys) this.observeArray(value) &#125; else &#123; this.walk(value) &#125; &#125; &#x2F;&#x2F; 遍历对象的 key 调用 defineReactive walk (obj: Object) &#123; const keys &#x3D; Object.keys(obj) for (let i &#x3D; 0; i &lt; keys.length; i++) &#123; defineReactive(obj, keys[i]) &#125; &#125; &#x2F;&#x2F; 遍历数组调用observe observeArray (items: Array&lt;any&gt;) &#123; for (let i &#x3D; 0, l &#x3D; items.length; i &lt; l; i++) &#123; observe(items[i]) &#125; &#125;&#125; definReactive定义一个响应式对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859export function defineReactive ( obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean) &#123; &#x2F;&#x2F; 实例化Dep对象 const dep &#x3D; new Dep() const property &#x3D; Object.getOwnPropertyDescriptor(obj, key) if (property &amp;&amp; property.configurable &#x3D;&#x3D;&#x3D; false) &#123; return &#125; &#x2F;&#x2F; cater for pre-defined getter&#x2F;setters const getter &#x3D; property &amp;&amp; property.get const setter &#x3D; property &amp;&amp; property.set if ((!getter || setter) &amp;&amp; arguments.length &#x3D;&#x3D;&#x3D; 2) &#123; val &#x3D; obj[key] &#125; &#x2F;&#x2F; 对子对象递归调用 let childOb &#x3D; !shallow &amp;&amp; observe(val) &#x2F;&#x2F;给对象添加getter和setter Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter () &#123; const value &#x3D; getter ? getter.call(obj) : val if (Dep.target) &#123; dep.depend() if (childOb) &#123; childOb.dep.depend() if (Array.isArray(value)) &#123; dependArray(value) &#125; &#125; &#125; return value &#125;, set: function reactiveSetter (newVal) &#123; const value &#x3D; getter ? getter.call(obj) : val &#x2F;* eslint-disable no-self-compare *&#x2F; if (newVal &#x3D;&#x3D;&#x3D; value || (newVal !&#x3D;&#x3D; newVal &amp;&amp; value !&#x3D;&#x3D; value)) &#123; return &#125; &#x2F;* eslint-enable no-self-compare *&#x2F; if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; customSetter) &#123; customSetter() &#125; if (setter) &#123; setter.call(obj, newVal) &#125; else &#123; val &#x3D; newVal &#125; childOb &#x3D; !shallow &amp;&amp; observe(newVal) dep.notify() &#125; &#125;)&#125; defineReactive的get方法 -&gt; 依赖收集dep.depen() deep 管理Watch对象 123456789101112131415161718192021222324252627282930313233export default class Dep &#123; &#x2F;&#x2F; target全局唯一 Watcher static target: ?Watcher; id: number; subs: Array&lt;Watcher&gt;; constructor () &#123; this.id &#x3D; uid++ this.subs &#x3D; [] &#125; &#x2F;&#x2F; 在 subs中添加Watcher，也就是添加属性发生改变时，要通知的watcher addSub (sub: Watcher) &#123; this.subs.push(sub) &#125; &#x2F;&#x2F; 移除Wathcer removeSub (sub: Watcher) &#123; remove(this.subs, sub) &#125; &#x2F;&#x2F; 依赖收集 depend () &#123; if (Dep.target) &#123; Dep.target.addDep(this) &#125; &#125; &#x2F;&#x2F; 通知Watcher更新，也就是派发更新 notify () &#123; &#x2F;&#x2F; stabilize the subscriber list first const subs &#x3D; this.subs.slice() for (let i &#x3D; 0, l &#x3D; subs.length; i &lt; l; i++) &#123; subs[i].update() &#125; &#125;&#125; Wathcer 123this.deps &#x3D; [] this.newDeps &#x3D; []&#x2F;&#x2F;表示Wather实例持有的Dep实例，也就是订阅了多少dep 组件挂载时调用mountComponent函数，在mountComponent中实例化一个渲染Wathcer-&gt;实例化Wathcer时调用this.get() 1234567891011121314151617get () &#123; pushTarget(this) let value const vm &#x3D; this.vm try &#123; value &#x3D; this.getter.call(vm, vm) &#125; catch (e) &#123; &#x2F;&#x2F; .... &#125; finally &#123; if (this.deep) &#123; traverse(value) &#125; popTarget() this.cleanupDeps() &#125; return value&#125; 调用pushTarget(this)将要挂载的组件渲染Wather对象赋值给Dep.target -&gt; 执行this.getter.call(vm,vm)-&gt;实际上是执行new Wathcer时传入的回调函数-&gt;执行updateComponent() 1new Watcher(vm, updateComponent, &#x2F;&#x2F;...) updateComponent有对组件data数据的访问-&gt; 触发defineReactive的get方法 -&gt; 依赖收集dep.depen()-&gt;调用Dep.target.addDep(this)-&gt;实际是调用渲染Watcher实例中的addDep 1234567891011addDep (dep: Dep) &#123; const id &#x3D; dep.id &#x2F;&#x2F; 保证同一数据不会被添加多次 if (!this.newDepIds.has(id)) &#123; this.newDepIds.add(id) this.newDeps.push(dep) if (!this.depIds.has(id)) &#123; dep.addSub(this) &#125; &#125;&#125; 将这个渲染Wather添加到在defineReactive中实例化的dep中的subs中,这就是整个依赖收集过程。set 1234567891011set: function reactiveSetter (newVal) &#123; const value &#x3D; getter ? getter.call(obj) : val &#x2F;&#x2F; .... if (setter) &#123; setter.call(obj, newVal) &#125; else &#123; val &#x3D; newVal &#125; childOb &#x3D; !shallow &amp;&amp; observe(newVal) dep.notify() &#125; observe(newVal)使新设置的值变成响应式的,dep.notify()通知所有订阅了这个dep的Wathcher对象-&gt; dep.notify()调用Watcher的update()方法 123456789101112131415update () &#123; if (this.computed) &#123; if (this.dep.subs.length &#x3D;&#x3D;&#x3D; 0) &#123; this.dirty &#x3D; true &#125; else &#123; this.getAndInvoke(() &#x3D;&gt; &#123; this.dep.notify() &#125;) &#125; &#125; else if (this.sync) &#123; this.run() &#125; else &#123; queueWatcher(this) &#125;&#125; 一般组件数据更新会调用queueWatcher(this)queueWathcer使用了队列，先把Wather添加到队列queue，在下个nextTick执行flushSchedulerQueue() -&gt; 执行watcher.run()方法 12345run () &#123; if (this.active) &#123; this.getAndInvoke(this.cb) &#125;&#125; run()方法执行-&gt;getAndInvoke(this.cb)传入回调函数-&gt;getAndInvoke判断满足新旧值不等-&gt;执行this.cb回调函数在渲染watcher中，this.cb为 123updateComponent &#x3D; () &#x3D;&gt; &#123; vm._update(vm._render(), hydrating)&#125; 所以当修改组件相关的响应式数据时会触发组件重新渲染 computed实现Vue实例初始化时调用initComputed()-&gt;在initComputed()中为每一个计算属性getter创建computed Wather,传入{computed: true}-&gt;computed Wathcer初始化时持有一个dep实例,这个dep实例用来管理computed Wathcerupdate()时，要更新的订阅了这个dep的watcher, 如渲染watcher 1234if (this.computed) &#123; this.value &#x3D; undefined this.dep &#x3D; new Dep()&#125; 最后调用defineComputed()defineComputed()-&gt;调用Object.defineProperty为计算属性对应的key的getter和setter,一般setter为空，getter对应createComputedGetter(key) 123456789function createComputedGetter (key) &#123; return function computedGetter () &#123; const watcher &#x3D; this._computedWatchers &amp;&amp; this._computedWatchers[key] if (watcher) &#123; watcher.depend() return watcher.evaluate() &#125; &#125;&#125; 当render 函数访问到计算属性时-&gt; 触发getter-&gt; 执行watcher.depend-&gt;将渲染Wather订阅上文实例化的dep-&gt;执行watcher.evaluate() 1234567evaluate () &#123; if (this.dirty) &#123; this.value &#x3D; this.get() this.dirty &#x3D; false &#125; return this.value&#125; watcher.evaluate()执行this.get()-&gt; this.get()为计算属性定义的getter函数获取到this.value值此时也会访问到计算属性所依赖的数据的getter,所以Dep.target为这个computed watcher,此时这个computed watcher订阅了所依赖数据持有的dep 当对计算属性依赖的数据做修改时-&gt;触发数据setter-&gt;通知订阅它变化的computed watcher更新-&gt; 执行watcher.update()方法 123456789if (this.computed) &#123; if (this.dep.subs.length &#x3D;&#x3D;&#x3D; 0) &#123; this.dirty &#x3D; true &#125; else &#123; this.getAndInvoke(() &#x3D;&gt; &#123; this.dep.notify() &#125;) &#125;&#125; 在上文中渲染Wather订阅了this.dep, 所以渲染Wathcer通过this.getAndInvoke()的回调执行update()-&gt;重新渲染组件this.getAndInvoke()主要是对比新旧值 在computed Watcher中this.dirty的作用时在重新渲染组件后，通过evalute()获取计算属性的值时，因为在getAndInvoke()中将this.value设为新值并置this.dirty为false,所以直接返回this.value，不触发所依赖数据的getter 1234&#x2F;&#x2F; 在 getAndInvoke()中const oldValue &#x3D; this.valuethis.value &#x3D; valuethis.dirty &#x3D; false watch的实现Vue实例初始化时-&gt;initWatch()-&gt;调用createWatcher(vm, key, handler[i])-&gt;返回vm.$watch(expOrFn, handler, options)$watch在执行stateMixin时定义实例化了Wathcer 1const watcher &#x3D; new Watcher(vm, expOrFn, cb, options) 是一个 user Wathcer, options.user = true,在实例化 user Wathcer时，调用了watcher的this.get()方法，之后的依赖收集和更新与一般组件数据相同,不同是对options属性值不同时，进入不同的分支.","categories":[{"name":"源码学习","slug":"源码学习","permalink":"http://lizehongss.github.io/newBlog/categories/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://lizehongss.github.io/newBlog/tags/vue/"}]},{"title":"vue数据驱动原理","slug":"vue数据驱动","date":"2019-05-15T00:00:00.000Z","updated":"2020-07-25T13:43:10.968Z","comments":true,"path":"2019/05/15/vue数据驱动/","link":"","permalink":"http://lizehongss.github.io/newBlog/2019/05/15/vue%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8/","excerpt":"","text":"Vue的定义 123456new Vue(&#123; el: &#39;#app&#39;, data: &#123; message: &#39;Hello Vue!&#39; &#125;&#125;) 1234function Vue (options) &#123; &#x2F;&#x2F;... this._init(options)&#125; new Vue()-&gt; 调用this._init(options)this._init初始化各种配置，包括初始化生命周期，初始化data,props, computed, watcher等等-&gt; 最后调用vm.$mout(vm.$options.el)挂载vm.带 compiler 版本的 $mount 实现 12345678910111213Vue.prototype.$mount &#x3D; function(&#x2F;&#x2F;...)&#123; &#x2F;&#x2F; 如this.$options.render不存在，调用compileToFunctions方法转换成render方法 const &#123; render, staticRenderFns &#125; &#x3D; compileToFunctions(template, &#123; shouldDecodeNewlines, shouldDecodeNewlinesForHref, delimiters: options.delimiters, comments: options.comments &#125;, this) options.render &#x3D; render options.staticRenderFns &#x3D; staticRenderFns &#x2F;&#x2F; 调用原先原型上的 $mount 方法挂载。 return mount.call(this, el, hydrating)&#125; 调用原先原型上的 $mount 方法定义如下: 12345678&#x2F;&#x2F; public mount methodVue.prototype.$mount &#x3D; function ( el?: string | Element, hydrating?: boolean): Component &#123; el &#x3D; el &amp;&amp; inBrowser ? query(el) : undefined return mountComponent(this, el, hydrating)&#125; 调用mountComponent(this, el, hydrating) 123456789101112131415&#x2F;&#x2F; ....&#x2F;&#x2F; 实例化渲染Wathcher new Watcher(vm, updateComponent, noop, &#123; before () &#123; if (vm._isMounted) &#123; callHook(vm, &#39;beforeUpdate&#39;) &#125; &#125; &#125;, true &#x2F;* isRenderWatcher *&#x2F;) if (vm.$vnode &#x3D;&#x3D; null) &#123; vm._isMounted &#x3D; true callHook(vm, &#39;mounted&#39;) &#125; &#x2F;&#x2F; 完成整个渲染工作 return vm new Wathcer 在初始化时会执行回调函数updateComponent且 vm 实例中的监测的数据发生变化的时候执行回调函数 12345&#x2F;&#x2F; 在watcher定义中, this.getter为传入的updateComponentget () &#123; &#x2F;&#x2F; ... value &#x3D; this.getter.call(vm, vm)&#125; 在整个过程中核心是vm._render和vm._update 123updateComponent &#x3D; () &#x3D;&gt; &#123; vm._update(vm._render(), hydrating)&#125; vm._render()用来把实例渲染成一个虚拟 Node，也就是VNode-&gt;调用vnode = render.call(vm._renderProxy, vm.$createElement)vm.$createElement定义如下： 1vm.$createElement &#x3D; (a, b, c, d) &#x3D;&gt; createElement(vm, a, b, c, d, true)","categories":[{"name":"源码学习","slug":"源码学习","permalink":"http://lizehongss.github.io/newBlog/categories/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://lizehongss.github.io/newBlog/tags/vue/"}]},{"title":"css布局","slug":"CSS布局","date":"2018-06-23T00:00:00.000Z","updated":"2020-07-25T13:43:10.968Z","comments":true,"path":"2018/06/23/CSS布局/","link":"","permalink":"http://lizehongss.github.io/newBlog/2018/06/23/CSS%E5%B8%83%E5%B1%80/","excerpt":"","text":"css布局（持续更新）将浮动元素围住 为父元素添加 overflow:hidden 属性演示如下： 同时浮动父元素 为父元素添加float:left演示如下： 添加非浮动元素的清除元素 代码如下 1234567.clear:after&#123; content:&quot;.&quot;; display:block; height:0; visibility:hidden; clear:both;&#125; 三栏一固定宽度布局 父元素wrapper 设定一固定宽度，水平外边距为auto 子元素nav和artice设置浮动，宽度相加为wrapper的宽度（再加以此类推） header和footer 默认与布局同宽 footer要清除浮动html代码如下： 1234567&lt;div id&#x3D;&quot;wrapper&quot;&gt;&lt;header&gt;&lt;!-- 标题 --&gt;header&lt;&#x2F;header&gt;&lt;nav&gt;&lt;!-- 无序列表 -- nav&lt;&#x2F;nav&gt;&lt;article&gt;&lt;! -- 文本 --&gt; article&lt;&#x2F;article&gt;&lt;aside&gt;&lt;! -- 文本 --&gt;aside&lt;&#x2F;aside&gt;&lt;footer&gt;&lt;!-- 文本 --&gt; footer&lt;&#x2F;footer&gt; css代码如下： 1234567891011121314151617181920212223242526#wrapper&#123; margin: 0 auto; width:960px; height:700px;&#125;header&#123; background:#dcd9c0; height:30px;&#125;nav&#123; width:150px; float:left; background:#dcd9c0; height:400px;&#125; article&#123; width:600px; float:left; background:#ffed53; height:400px;&#125;aside&#123; width:210px; float:left; background:#3f7ccf; height:400px;&#125;footer&#123; clear:both; background:#000; height:40px;&#125; 各栏边界分开的解决方法： 为子元素里的内容加一个div,为div设置一个内边距 为浮动栏设置 box-sizing:border-box 以及内边距和边框即可– IE7和IE8不支持 三栏–中栏流动布局 方法一 用一个div class为threecolarap 包围全部三栏并为其设置浮动 用一个div class为twocolarap包围左栏和中栏并为其设置浮动以及加上 margin-right:210px 把右栏拉到区块外边距腾出的位置上 中栏加上 margin-right:210px 在流动居中的栏右测腾出空间 方法二 为每一栏display属性设定为table-cell (IE7不支持)补充元素居中 为父元素应用 text-algin:center 为要居中的元素设定 display:inline-block","categories":[{"name":"css","slug":"css","permalink":"http://lizehongss.github.io/newBlog/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://lizehongss.github.io/newBlog/tags/css/"}]},{"title":"js算法3","slug":"算法3","date":"2018-03-31T00:00:00.000Z","updated":"2020-07-25T13:43:10.968Z","comments":true,"path":"2018/03/31/算法3/","link":"","permalink":"http://lizehongss.github.io/newBlog/2018/03/31/%E7%AE%97%E6%B3%953/","excerpt":"","text":"要求介绍 个人代码： 12345678910111213function encode(str, n)&#123; var arr &#x3D;[]; var j&#x3D;0; var n &#x3D; n.toString().split(&#39;&#39;).map(Number); for(var i &#x3D;0;i&lt;str.length;i++)&#123; arr.push((str[i].charCodeAt()-96)); arr[i]&#x3D;arr[i]+n[j]; j++; if(j&#x3D;&#x3D;n.length) j&#x3D;0; &#125; return arr;&#125; 别人代码 1234function encode(str, n) &#123; const key &#x3D; String(n) return Array.from(str, (c, i) &#x3D;&gt; c.charCodeAt(0) - 96 + Number(key[i % key.length]))&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://lizehongss.github.io/newBlog/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://lizehongss.github.io/newBlog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"js算法2","slug":"算法2","date":"2018-03-23T00:00:00.000Z","updated":"2020-07-25T13:43:10.968Z","comments":true,"path":"2018/03/23/算法2/","link":"","permalink":"http://lizehongss.github.io/newBlog/2018/03/23/%E7%AE%97%E6%B3%952/","excerpt":"","text":"首字母大写 代码如下 ： 123456789function capitalizeWord(word) &#123; var r &#x3D;word.charAt(0); var s&#x3D;r.toUpperCase();var arr&#x3D;word.split(&#39;&#39;); arr[0]&#x3D;s; var arrs&#x3D;arr.toString().replace(&#x2F;,&#x2F;g , &quot;&quot;); return arrs;&#125; 别人代码： 1234function capitalizeWord(word) &#123; return word[0].toUpperCase() + word.slice(1); &#x2F;&#x2F;删除第一个字母&#125; 计算体积并得出差值代码如下：12345678910111213141516171819function findDifference(a, b) &#123; &#x2F;&#x2F;loading... var s1&#x3D;1,s2&#x3D;1; for(var i&#x3D;0;i&lt;a.length;i++)&#123; s1&#x3D;s1*a[i]; &#125; for(var i&#x3D;0;i&lt;b.length;i++)&#123; s2&#x3D;s2*b[i]; &#125; if(s1&gt;s2)&#123; return s1-s2; &#125; if(s1&lt;s2)&#123; return s2-s1; &#125; if(s1&#x3D;&#x3D;s2)&#123; return 0; &#125;&#125; 别人代码如下： 123function find_difference(a, b) &#123; return Math.abs(a.reduce((previous, current) &#x3D;&gt; previous * current) - b.reduce((previous, current) &#x3D;&gt; previous * current));&#125; 返回数组中不重复的值代码如下:123456function stray(numbers)&#123; for (var i in numbers)&#123; if (numbers.indexOf(numbers[i]) &#x3D;&#x3D;&#x3D; numbers.lastIndexOf(numbers[i]))&#123;return numbers[i]&#125; &#125;&#125;&#x2F;&#x2F;向前和向后搜索，如果索引相同说明只有一个，可以返回 转换Number类型示例如下：348597 =&gt; [7,9,5,8,4,3]代码如下：12345678function digitize(n) &#123; var s&#x3D;n.toString(); var arr&#x3D;[]; for(var i&#x3D;0;i&lt;s.length;i++)&#123; arr.push(s[i]); &#125; return arr.map(Number).reverse();&#125; 别人代码系列123function digitize(n)&#123; return (n + &#39;&#39;).split(&#39;&#39;).map(Number).reverse();&#125; solution(‘world’); // returns ‘dlrow’ 代码如下： 123var arr &#x3D;str.split(&#39;&#39;); arr&#x3D;arr.sort().toString().replace(&#x2F;,&#x2F;g,&#39;&#39;); return arr; 别人代码： 123function solution(str)&#123; return str.split(&#39;&#39;).reverse().join(&#39;&#39;); &#125; 简单的运算 代码如下： 1234567891011121314function basicOp(operation, value1, value2) &#123; switch (operation) &#123; case &#39;+&#39;: return value1 + value2; case &#39;-&#39;: return value1 - value2; case &#39;*&#39;: return value1 * value2; case &#39;&#x2F;&#39;: return value1 &#x2F; value2; default: return 0; &#125;&#125; 别人代码： 1234function basicOp(o, a, b) &#123; return eval(a+o+b);&#125;&#x2F;&#x2F;eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。","categories":[{"name":"算法","slug":"算法","permalink":"http://lizehongss.github.io/newBlog/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://lizehongss.github.io/newBlog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"面试2","slug":"面试2","date":"2018-03-23T00:00:00.000Z","updated":"2020-07-25T13:43:10.968Z","comments":true,"path":"2018/03/23/面试2/","link":"","permalink":"http://lizehongss.github.io/newBlog/2018/03/23/%E9%9D%A2%E8%AF%952/","excerpt":"","text":"浏览器如何解析css CSS选择器的解析是从右向左解析的。若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 Render Tree。 数组和对象的原生方法数组方法有 转换方法：toLocaleString(),toString(),valueOf() 栈方法：push(),pop() 队列方法 shift(),unshif() 重排序方法 reverse() ,sort() 操作方法 concat() slice() splice() 位置方法 indexOf() lastIndexOf() 迭代方法 ecery() filter() fotEach() map() some() 归并方法 reduce() reduceRight() 如果需要手动写动画，你认为最小时间间隔是多久，为什么？ 多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms。 作用域问题(专开坑) js数据类型并写出它们的内存图 js数据类型：Undefined Null Boolean Number String Object JS中的基础数据类型，这些值都有固定的大小，往往都保存在栈内存中，由系统自动分配存储空间。我们可以直接操作保存在栈内存空间的值 jS的引用数据类型，比如数组Array，它们值的大小是不固定的。引用数据类型的值是保存在堆内存中的对象。 null和undefine的区别 答案 为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式 父元素的高度无法被撑开，影响与父元素同级的元素 与浮动元素同级的非浮动元素（内联元素）会跟随其后 若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构。方法： 父级div定义height 最后一个浮动元素后加空div标签 并添加样式clear:both。 包含浮动元素的父标签添加样式overflow为hidden或auto。 父级div定义zoom :after和::after有什么区别，有什么作用 作用 使得html更加语义化。有些时候，为了某些特定的展现，不得不添加用于辅助布局的无意义html元素，这两个伪元素能实际起到这种辅助布局的作用，而又不增加无意义纯布局html元素，所以html就更简洁更纯粹了。 区别before/:after这种写法css2中就有，叫伪类；::befroe/::after这种写法是css3中的，叫伪元素，但两种写法的作用是一样的。后者无法兼容IE低版本，如果要求兼容IE低版本请使用前者。注：对于img和input元素两者都不起作用","categories":[{"name":"面试","slug":"面试","permalink":"http://lizehongss.github.io/newBlog/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://lizehongss.github.io/newBlog/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"面试3","slug":"面试3","date":"2018-03-23T00:00:00.000Z","updated":"2020-07-25T13:43:10.968Z","comments":true,"path":"2018/03/23/面试3/","link":"","permalink":"http://lizehongss.github.io/newBlog/2018/03/23/%E9%9D%A2%E8%AF%953/","excerpt":"","text":"vue 生命周期 beforecreated：el 和 data 并未初始化 created:完成了 data 数据的初始化，el没有 beforeMount：完成了 el 和 data 初始化 mounted ：完成挂载 beforecreate : 举个栗子：可以在这加个loading事件 created ：在这结束loading，还做一些初始化，实现函数自执行 mounted ： 在这发起后端请求，拿回数据，配合路由钩子做一些事情 beforeDestroy： 你确认删除XX吗？ destroyed ：当前组件已被删除，清空相关内容 组件通信 父组件向子组件通信 使用props即可 子组件向父组件通信 使用自定义事件，子组件用$emit()来触发向父组件通信的事件 非父子组件通信 在vue.js2.x中使用一个空的vu实例来作中介，组件把自定义事件名称和数据发送到这个空实例，其它实例或组件通过监听空实例的自定义事件来刷新数据 网络状态 1XX 成功 2XX 重定向 3XX 客户机中出现的错误 400 请求无效 闭包应用场景 闭包通常用来创建内部变量，使得这些变量不能被外部随意修改，同时又可以通过指定的函数接口来操作。","categories":[{"name":"面试","slug":"面试","permalink":"http://lizehongss.github.io/newBlog/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://lizehongss.github.io/newBlog/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"js算法1","slug":"算法1","date":"2018-03-23T00:00:00.000Z","updated":"2020-07-25T13:43:10.968Z","comments":true,"path":"2018/03/23/算法1/","link":"","permalink":"http://lizehongss.github.io/newBlog/2018/03/23/%E7%AE%97%E6%B3%951/","excerpt":"","text":"js相关算法 传入四个正整数参数，返回最小的两个，代码如下：12345678910function sumTwoSmallestNumbers(numbers) &#123; var min&#x3D;Math.min.apply(Math,numbers); var filterResult&#x3D; numbers.filter((item)&#x3D;&gt;&#123; return (item!&#x3D;min) &#125; ) var smin&#x3D;Math.min.apply(Math,filterResult); return min+smin; &#x2F;&#x2F;Code here&#125;; 最优解(别人代码系列)12345function sumTwoSmallestNumbers(numbers)&#123; numbers &#x3D; numbers.sort(function(a, b)&#123;return a - b; &#125;); return numbers[0] + numbers[1];&#125;;&#x2F;&#x2F;使用排序解决。。。。 给定一个正整数n写成abcd …（a，b，c，d…是数字）和一个正整数p，我们想要找到一个正整数k，如果存在的话，比如数字的总和对于p的连续幂的n等于k * n。换一种说法：例如：（a ^ p + b ^（p + 1）+ c ^（p + 2）+ d ^（p + 3）+ …）= n * k如果是这种情况，我们将返回K，如果不返回-1。注：N，P将始终作为严格正整数给出。代码如下：1234567891011function digPow(n, p)&#123; &#x2F;&#x2F; ... var s&#x3D;n.toString(); var sum &#x3D;0; for(var i&#x3D;0;i&lt;s.length;i++)&#123; sum+&#x3D;Math.pow(s[i],p); p++; &#125; if(sum%n&#x3D;&#x3D;0) return sum&#x2F;n; else return -1;&#125; 最优解(别人代码系列)12345678function digPow(n, p) &#123; var x &#x3D; String(n).split(&quot;&quot;).reduce((s, d, i) &#x3D;&gt; s + Math.pow(d, p + i), 0) return x % n ? -1 : x &#x2F; n&#125;&#x2F;&#x2F;reduce中s为上一次调用回调函数时的返回值，或者初始值&#x2F;&#x2F;d为当前正在处理的数组元素&#x2F;&#x2F;i为当前数组元素下标&#x2F;&#x2F;初始值为0 找到n下面所有倍数的总和m，例子： sumMul(2, 9) ==&gt; 2 + 4 + 6 + 8 = 20 sumMul(3, 13) ==&gt; 3 + 6 + 9 + 12 = 30 sumMul(4, 123) ==&gt; 4 + 8 + 12 + … = 1860 sumMul(4, -7) ==&gt; “INVALID”代码如下： 12345678910111213function sumMul(n,m)&#123;&#x2F;&#x2F;your idea herevar sum&#x3D;0;var double&#x3D;1;var val&#x3D;n;while(val&lt;m)&#123;sum+&#x3D;val;double++;val&#x3D;n*double;&#125;if(sum&#x3D;&#x3D;0) return &quot;INVALID&quot;;return sum;&#125; 别人代码 123456789function sumMul(n,m)&#123; if (n &gt;&#x3D; m) return &quot;INVALID&quot;;var sum &#x3D; 0; for (var i &#x3D; n; i &lt; m; i+&#x3D;n) &#123; sum +&#x3D; i; &#125; return sum;&#125; 公差公式，示例如下： arithmetic_sequence_elements(1, 2, 5) == “1, 3, 5, 7, 9”代码如下：1234567891011121314function arithmeticSequenceElements(a,r,n) &#123; &#x2F;&#x2F;your code here var arr &#x3D;[]; var i&#x3D;0; while(arr.length&lt;n)&#123; if(i&#x3D;&#x3D;0)&#123; arr[i]&#x3D;a&#125; else arr[i]&#x3D;&#39; &#39;+a; a&#x3D;a+r; i++; &#125; arr&#x3D;arr.toString(); return arr;&#125; 别人代码系列:12345function arithmeticSequenceElements(a,r,n) &#123; var ret &#x3D; [a] while (--n) ret.push(a+&#x3D;r); return ret.join(&#39;, &#39;)&#125; 去除！示例如下： remove(“Hi!”) == “Hi!” remove(“Hi!!!”) == “Hi!!!” remove(“!Hi”) == “Hi” remove(“!Hi!”) == “Hi!” remove(“Hi! Hi!”) == “Hi Hi!” remove(“Hi”) == “Hi” 代码如下： 123456function remove(s)&#123; &#x2F;&#x2F;coding and coding.... var a&#x3D;&#x2F;!+[^!$]&#x2F;gm; return s.replace(a,&quot; &quot;);&#125;&#x2F;&#x2F;自己的想法，然后有两个没过。 别人代码系列： 12345function remove(s)&#123; var a&#x3D;&#x2F;!+(?!!*$)&#x2F;g; return s.replace(a, &#39;&#39;);&#125;总体思路是对，不匹配最后的！用零宽负向先行断言，要求接下来的字符不与!匹配 返回最大和最小，示例如下： highAndLow(“1 2 3 4 5”); // return “5 1” highAndLow(“1 2 -3 4 5”); // return “5 -3” highAndLow(“1 9 3 4 -5”); // return “9 -5” 代码如下： 123456789101112function highAndLow(numbers)&#123; &#x2F;&#x2F; ... var arr &#x3D;numbers.split(&#x2F;[\\ ]+&#x2F;); var arr&#x3D;arr.map(function(item)&#123; return parseInt(item); &#125;) var max&#x3D;Math.max.apply(Math,arr); var min&#x3D;Math.min.apply(Math,arr); console.log(max); return max.toString()+&quot; &quot;+min.toString(); &#125; 别人代码 ： 1234function highAndLow(numbers)&#123; numbers &#x3D; numbers.split(&#39; &#39;).map(Number); return Math.max.apply(0, numbers) + &#39; &#39; + Math.min.apply(0, numbers);&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://lizehongss.github.io/newBlog/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://lizehongss.github.io/newBlog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"面试1","slug":"面试1","date":"2018-03-22T00:00:00.000Z","updated":"2020-07-25T13:43:10.968Z","comments":true,"path":"2018/03/22/面试1/","link":"","permalink":"http://lizehongss.github.io/newBlog/2018/03/22/%E9%9D%A2%E8%AF%951/","excerpt":"","text":"清除浮动方法1：:after方法123456:after&#123; content: &quot;.&quot;; clean：both;display:block;height: 0px;&#125; 方法2：父元素设置overflow:hidden1234.f&#123; overflow:hidden; &#125; 方法3：添加空div标签clean:both123.clean-both&#123; clean:both;&#125; div垂直和水平居中方法1 使用absolute+transform123456789.parent&#123; position: relative;&#125;.child&#123; position:absolute; left:50%; top:50%; transform:tranplate(-50%,-50%);&#125; 方法2 inline-block+text-align12345678.parent&#123; text-align:center; display:table-cell; vertical-align:middle;&#125;.child&#123; display:inline-block;&#125; 方法3 flex12345.parent&#123; display:flex; justify-content:center; align-items:center;&#125; DOM操作获取子元素并插入1234&lt;ul&gt;&lt;li&gt;1&lt;&#x2F;li&gt;&lt;li&gt;3&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt; 代码如下：12345var li&#x3D;document.createElement(&quot;li&quot;);var textNode&#x3D;document.createTextNode(&quot;2&quot;);li.appendChild(textNode);var ul&#x3D;document.getElementsByTagName(&quot;ul&quot;);ul.insertBefore(li,ul.childNodes[1]); 数组去重遍历，将数组的值添加到一个对象的属性名里，并给属性赋值，对象不能添加相同属性名，以这个为依据可以实现数组去重，然后用Object.keys(对象)返回这个对象可枚举属性组成的数组，这个数组就是去重后的数组。1234567891011121314 let a &#x3D; [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, 1,NaN,NaN,undefined,undefined,null,null, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;]; const unique &#x3D; arr &#x3D;&gt; &#123; var obj &#x3D; &#123;&#125; arr.forEach(value &#x3D;&gt; &#123; obj[value] &#x3D; 0;&#x2F;&#x2F;这步新添加一个属性，并赋值，如果不赋值的话，属性会添加不上去 &#125;) return Object.keys(obj);&#x2F;&#x2F;&#96;Object.keys(对象)&#96;返回这个对象可枚举属性组成的数组，这个数组就是去重后的数组 &#125; console.log(unique(a));&#x2F;&#x2F;[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;NaN&quot;, &quot;undefined&quot;, &quot;null&quot;, &quot;a&quot;, &quot;b&quot;]作者：OBKoro1链接：https:&#x2F;&#x2F;juejin.im&#x2F;post&#x2F;5aad40e4f265da237f1e12ed来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 es6123let unique&#x3D; [...new Set(array)];&#x2F;&#x2F;es6 Set数据结构类似于数组，成员值是唯一的，有重复的值会自动去重。&#x2F;&#x2F;Set内部使用&#x3D;&#x3D;&#x3D;来判断是否相等，类似&#39;1&#39;和1会两个都保存，NaN和NaN只会保存一个 提高页面加载速度 减少dom操作 部署前，图片压缩，代码压缩 优化js代码结构，减少冗余代码 减少http请求，合理设置 HTTP缓存 使用内容分发cdn加速 静态资源缓存 图片延迟加载 作用域问题1234567891011121314151617181920212223function F()&#123; var arr&#x3D;[],i; for(i&#x3D;0;i&lt;3;i++)&#123; arr[i]&#x3D;function()&#123; return i; &#125;; &#125; return arr ;&#125;结果都为3;闭包问题方法为function F()&#123; function binder(x)&#123; return function()&#123; return x; &#125;; &#125; var arr &#x3D;[],i; for(i&#x3D;0;i&lt;3;i++)&#123; arr[i]&#x3D;binder(i); &#125; return arr;&#125; vue数据监控 使用watch监控 使用计算属性 过渡器","categories":[{"name":"面试","slug":"面试","permalink":"http://lizehongss.github.io/newBlog/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://lizehongss.github.io/newBlog/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"vue学习笔记(二)————组件","slug":"vue学习笔记-组件 ","date":"2018-02-10T00:00:00.000Z","updated":"2020-07-25T13:43:10.968Z","comments":true,"path":"2018/02/10/vue学习笔记-组件 /","link":"","permalink":"http://lizehongss.github.io/newBlog/2018/02/10/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BB%84%E4%BB%B6%20/","excerpt":"","text":"前言主要是有关vue组件的笔记，然后也不想为了定blog而写blog,所以应该会写一些真的自己想记下来的东西，也希望可以尽量精简的写 组件用法需要注册才能使用组件，注册分为局部注册和全局注册，代码示例如下： 必须在实例注册，组件才可以使用 123456789101112&#x2F;&#x2F;全局注册Vue.component(&quot;组件名&quot;,&#123; &#x2F;&#x2F;选项 &#125;);&#x2F;&#x2F;局部注册var 组件名 &#x3D;&#123; &#x2F;&#x2F;选项&#125;html模板如下：&lt;组件名&gt;&lt;&#x2F;组件名 组件选项templatetemlplate后面是要渲染的内容，必须有一个元素包围它，代码如下： 注意v-show不能用在template中，可以使用v-if 1234Vue.component(&quot;组件名&quot;,&#123;template: &#39;&lt;div&gt;&lt;&#x2F;div&gt;&#39;; &#125;); datadata的用法与实方法相同，不同的是要将数据return出去，代码如下： 12345678910Vue.component(&quot;组件名&quot;,&#123;.....data : function&#123; return &#123; mws: &quot;text&quot; &#125;&#125; &#125;); propsprops主要是用来接收来自父组件的数据，可以是字符串数组和对象注意数据是单向的，只能父组件传到子组件代码如下： 123456789html:&lt;mytext message&#x3D;&quot;text&quot;&gt;&lt;&#x2F;mytext&gt;js：Vue.component(&quot;mytext&quot;,&#123; props:[&#39;message&#39;] &#125;); props的数据可以进行验证，代码如下： 12345678props: &#123; message : &#123; type:Number， &#x2F;&#x2F;类型 default:&quot;&quot;text &#x2F;&#x2F;如果没有定义的默认值 &#125; &#125;&#125; wath 主要是用来监听props的值的改变，从而通知父组件或者更新props值 代码如下 123456watch:&#123; message: function(val)&#123; &#x2F;&#x2F;当message发生改变时触发的函数 &#x2F;&#x2F;val 为更新后的message值 &#125;&#125; 组件通信父组件向子组件通信使用上面的props即可 子组件向父组件通信使用自定义事件，子组件用$emit()来触发向父组件通信的事件代码如下： 12345678910111213html:&lt;mytext @send&#x3D;&quot;handle&quot;&gt;&lt;&#x2F;mytext&gt;&#x2F;&#x2F;其中send为子组件发送过来的参数，为自定义事件的名称Vue.component(&quot;mytext&quot;,&#123;template:&#39;&lt;button @click&#x3D;&quot;hadles&quot;&gt;&#39;,methods:&#123; hadles: function()&#123; this.$emit(&#39;handle&#39;,数据); &#x2F;&#x2F;第一个参数为事件名称，第二个为发送的数据 &#125;&#125; &#125;); 可以使用v-model来简化，不过个人感觉没有必要，所以不想写在这里做总结。。。。。。 非父子组件通信在vue.js2.x中使用一个空的vu实例来作中介，组件把自定义事件名称和数据发送到这个空实例，其它实例或组件通过监听空实例的自定义事件来刷新数据代码如下： 123var bus &#x3D;new Vue();bus.$emit(&#39;clicks&#39;,mes);bus.$on(&#39;clicks&#39;,function()&#123;&#125;); 补充：当子组件较多时，可以用ref属性为组件指定一个索引名称：代码如下: 1234html代码如下：&lt;mytext ref&#x3D;&quot;A&gt;&lt;&#x2F;mytext&gt;&#x2F;&#x2F;调用指定的子组件的messagevar msg&#x3D;this.$refs.comA.message slotslot是内容分发，用在将父组件的dom结构挂载，它与props,events触发事件构成组件的3个APi来源.slot的作用域是在父组件上代码如下： 12345678910111213&lt;mytext&gt;&lt;p&gt;&lt;&#x2F;p&gt;&#x2F;&#x2F;挂载内容 &lt;&#x2F;mytext&gt;Vue.component(&quot;mytext&quot;,&#123;template:&#39; &lt;div&gt; &lt;slot&gt; &lt;p&gt;&lt;&#x2F;p&gt;&#x2F;&#x2F;没有内容时的默认内容 &lt;&#x2F;slot&gt;&#x2F;&#x2F;父组件的内容将挂载在slot里面 &lt;&#x2F;div&gt;&#39; &#125;); 可以给slot指定一个name，使用分发指定内容代码如下： 123456789101112&lt;mytext&gt;&lt;p slot&#x3D;&quot;one&quot;&gt;&lt;&#x2F;p&gt;&#x2F;&#x2F;挂载内容,slot为具名slot&lt;&#x2F;mytext&gt;Vue.component(&quot;mytext&quot;,&#123;template:&#39; &lt;div&gt; &lt;slot&gt; &lt;p&gt;&lt;&#x2F;p&gt;&#x2F;&#x2F;没有内容时的默认内容 &lt;&#x2F;slot&gt;&#x2F;&#x2F;父组件的内容将挂载在slot里面 &lt;slot name&#x3D;&quot;one&quot;&gt;&#x2F;&#x2F;具名slot将分发在这里 &lt;&#x2F;div&gt;&#39; 也可以指定数据传递到父组件的挂载里，使用scope,代码如下： 123456789101112131415&lt;mytext&gt;&lt;p slot&#x3D;&quot;one&quot; scope&#x3D;&quot;props&quot;&gt; &#123;&#123;props.msg&#125;&#125; &#x2F;&#x2F;显示子组件的msg&lt;&#x2F;p&gt;&#x2F;&#x2F;挂载内容,slot为具名slot,props为临时变量&lt;&#x2F;mytext&gt;Vue.component(&quot;mytext&quot;,&#123;template:&#39; &lt;div&gt; &lt;slot&gt; &lt;p&gt;&lt;&#x2F;p&gt;&#x2F;&#x2F;没有内容时的默认内容 &lt;&#x2F;slot&gt;&#x2F;&#x2F;父组件的内容将挂载在slot里面 &lt;slot name&#x3D;&quot;one&quot; msg&#x3D;&quot;数据&quot;&gt;&#x2F;&#x2F;具名slot将分发在这里 &#x2F;&#x2F;msg为向父组件传递的数据 &lt;&#x2F;div&gt;&#39; 可以使用$slots访问分发的内容 1var header &#x3D;this.$slots.one; 结语还有许多关于组件的高级用法，不过我不是大佬，等以后用到再写吧。写完收工睡觉","categories":[{"name":"vue","slug":"vue","permalink":"http://lizehongss.github.io/newBlog/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://lizehongss.github.io/newBlog/tags/vue/"}]},{"title":"vue学习笔记(一)————基础知识","slug":"vue学习笔记-基础知识","date":"2018-02-06T00:00:00.000Z","updated":"2020-07-25T13:43:10.968Z","comments":true,"path":"2018/02/06/vue学习笔记-基础知识/","link":"","permalink":"http://lizehongss.github.io/newBlog/2018/02/06/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"前言学习vue的笔记，应该会试着写一个系列，目的还是加深印象，毕竟感觉自己的记忆力真的不ok,也是给自己的学习留下一点东西 创建vue实例和数据12345678var app &#x3D; new Vue(&#123; el:&#39;#app&#39;，&#x2F;&#x2F;指定挂载vue实例的元素，一般为id data:&#123; &#x2F;&#x2F;数据 a:1 &#125; &#125;) 在html中使用来显示数据， 是双向绑定的 生命周期vue 常用的生命周期钩子为 语法 | 简介 ——— | ————created | 实例创建完成后调用mounted | el挂载到实例上后调用beforeDestroy | 实例销毁之前调用 用法示例： 1234567891011ar app &#x3D; new Vue(&#123; el:&#39;#app&#39;，&#x2F;&#x2F;指定挂载vue实例的元素，一般为id data:&#123; &#x2F;&#x2F;数据 a:1 &#125; created: function()&#123; &#x2F;&#x2F;函数 &#125; &#125;) 过滤器 过滤器应该写在filters中,主要对数据进行过滤，如格式化文本，字母全部大写 12345678910ar app &#x3D; new Vue(&#123; el:&#39;#app&#39;, data:&#123; &#125; filters:&#123; b: function ()&#123; &#x2F;&#x2F;函数 &#125; &#125; &#125;) html中写法为： 1&#123;&#123;a|b&#125;&#125; 过滤器也可以串联接收数据 1&#123;&#123;a|b|c&#125;&#125; #计算属性计算属性应该写在computed中，应用在过长的逻辑运算 123456789&#123;&#123;d&#125;&#125;ar app &#x3D; new Vue(&#123; .... computed: d:function()&#123; return &#x2F;&#x2F;返回结果 &#125; &#125;) 注意: 计算属性不仅可以依赖当前Vue实例的数据，也可以依赖其它实例的数据 计算属性是基于它的依赖缓存的，只要数据不改变，计算属性不更新 基本指令v-bind动态更新HTML元素上的属性 123456789&lt;a v-bind:href&#x3D;&quot;url&quot;&gt;&lt;&#x2F;a&gt;ar app &#x3D; new Vue(&#123; ... data:&#123; url:... &#125; &#125;) 语法糖为： 如 ：href=”url” v-on绑定事件监听器 1234567891011&lt;button v-on:click&#x3D;&quot;a&quot;&gt;&lt;&#x2F;button&gt;ar app &#x3D; new Vue(&#123; .... methods:&#123; a: function()&#123; &#x2F;&#x2F;函数 &#125; &#125; &#125;) 在供click调用的方法，可以不加括号，可用$event访问原生DON事件，如： 1v-on:click&#x3D;&quot;a(mes,$event)&quot; 语法糖为@ 如 @click=”a”在vue中提供修饰符来实现各种事件方法的绑定，其中包括 语法 | 简介 ——— | —————-@click.stop | 阻止事件冒泡@click.prevent| 提交事件不再重载页面@click.once | 只触发一次@keyup.13 | 监听键盘事件，键值为13 其中@keyup还提供其它键值的快捷名称，可在vue文档查找，如@keyup.down 其它指令语法 | 简介 ——— | —————-v-html | 输出htmlv-cloak | 在vue实例结束编译时从绑定的HTML元素上移除v-once | 定义它的元素或组件只渲染一次v-if v-eles-if v-else | 与if等相同，后加判断式v-show | 改变元素的CSS属性display，false时会隐藏v-for |与for类似，与in搭配使用","categories":[{"name":"vue","slug":"vue","permalink":"http://lizehongss.github.io/newBlog/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://lizehongss.github.io/newBlog/tags/vue/"}]}],"categories":[{"name":"源码学习","slug":"源码学习","permalink":"http://lizehongss.github.io/newBlog/categories/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"name":"面试","slug":"面试","permalink":"http://lizehongss.github.io/newBlog/categories/%E9%9D%A2%E8%AF%95/"},{"name":"css","slug":"css","permalink":"http://lizehongss.github.io/newBlog/categories/css/"},{"name":"算法","slug":"算法","permalink":"http://lizehongss.github.io/newBlog/categories/%E7%AE%97%E6%B3%95/"},{"name":"vue","slug":"vue","permalink":"http://lizehongss.github.io/newBlog/categories/vue/"}],"tags":[{"name":"element","slug":"element","permalink":"http://lizehongss.github.io/newBlog/tags/element/"},{"name":"vue","slug":"vue","permalink":"http://lizehongss.github.io/newBlog/tags/vue/"},{"name":"css","slug":"css","permalink":"http://lizehongss.github.io/newBlog/tags/css/"},{"name":"算法","slug":"算法","permalink":"http://lizehongss.github.io/newBlog/tags/%E7%AE%97%E6%B3%95/"},{"name":"面试","slug":"面试","permalink":"http://lizehongss.github.io/newBlog/tags/%E9%9D%A2%E8%AF%95/"}]}