{"meta":{"title":"lzh","subtitle":"简单生活","description":"lzh的个人博客,主要为记录","author":"lizehong","url":"http://lizehongss.github.io/newBlog","root":"/newBlog/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-07-25T12:35:54.156Z","updated":"2020-07-25T12:35:54.156Z","comments":false,"path":"/404.html","permalink":"http://lizehongss.github.io/newBlog/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-07-25T12:35:54.160Z","updated":"2020-07-25T12:35:54.160Z","comments":false,"path":"about/index.html","permalink":"http://lizehongss.github.io/newBlog/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2020-07-25T12:35:54.160Z","updated":"2020-07-25T12:35:54.160Z","comments":false,"path":"books/index.html","permalink":"http://lizehongss.github.io/newBlog/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-07-25T12:35:54.160Z","updated":"2020-07-25T12:35:54.160Z","comments":false,"path":"categories/index.html","permalink":"http://lizehongss.github.io/newBlog/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-07-25T12:35:54.160Z","updated":"2020-07-25T12:35:54.160Z","comments":true,"path":"links/index.html","permalink":"http://lizehongss.github.io/newBlog/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-07-25T12:35:54.160Z","updated":"2020-07-25T12:35:54.160Z","comments":false,"path":"repository/index.html","permalink":"http://lizehongss.github.io/newBlog/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-07-25T12:35:54.160Z","updated":"2020-07-25T12:35:54.160Z","comments":false,"path":"tags/index.html","permalink":"http://lizehongss.github.io/newBlog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"element源码样式学习","slug":"element源码样式学习","date":"2020-04-20T00:00:00.000Z","updated":"2020-07-25T12:35:54.160Z","comments":true,"path":"2020/04/20/element源码样式学习/","link":"","permalink":"http://lizehongss.github.io/newBlog/2020/04/20/element%E6%BA%90%E7%A0%81%E6%A0%B7%E5%BC%8F%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"element源码样式学习目录结构element的样式存放在element的packages/theme-chalk中,目录结构如下所示: 123456789101112131415161718192021222324252627282930313233343536373839│ alert.scss &#x2F;&#x2F;组件样式│ aside.scss│ autocomplete.scss│ avatar.scss│ backtop.scss│ badge.scss│ base.scss│ breadcrumb-item.scss│ breadcrumb.scss│ button-group.scss│ button.scss| &#x2F;&#x2F; 省略部分组件样式├─common &#x2F;&#x2F; 组件共用样式│ popup.scss &#x2F;&#x2F;弹层类组件共用样式│ transition.scss &#x2F;&#x2F;主要定义了element组件中使用vue的 transition 组件时用到的动态效果样式│ var.scss &#x2F;&#x2F; 定义了element各组件UI的基本样式的变量,包括颜色,文本大小,边框大小,组件不同尺寸对应的不同样式│ ├─date-picker &#x2F;&#x2F; date组件使用样式│ date-picker.scss│ date-range-picker.scss│ date-table.scss│ month-table.scss│ picker-panel.scss│ picker.scss│ time-picker.scss│ time-range-picker.scss│ time-spinner.scss│ year-table.scss│ ├─fonts &#x2F;&#x2F; 字体文件│ element-icons.ttf│ element-icons.woff│ └─mixins &#x2F;&#x2F; scss复用函数 config.scss &#x2F;&#x2F; 样式名的全局配置 function.scss &#x2F;&#x2F; 组件样式使用到的sccss函数 mixins.scss &#x2F;&#x2F; 共用的mixins函数 utils.scss &#x2F;&#x2F; 工具类函数样式, 如禁用用户选择 _button.scss &#x2F;&#x2F; 按钮基本样式 主要文件分析config.scssconfig.scss 文件定义了element样式的全局配置,如样式名前缀,,样式名分割符等 123456// 这四个样式名配置是element所有样式名定义的基础// 如: el-button, el-select, is-disabled等样式名$namespace: 'el';$element-separator: '__';$modifier-separator: '--';$state-prefix: 'is-'; mixins.scssmixins.scss 文件定义了element各组件样式使用的基本mixins,这里对最主要的mixinx做分析 @mixin b() 混入el 123456789@mixin b($block) &#123; &#x2F;&#x2F; 假如 $block为button $B: $namespace+&#39;-&#39;+$block !global; $namespace在config.scss中定义为el,故$B为el-blutton .#&#123;$B&#125; &#123; &#x2F;&#x2F; .#&#123;&#125; 为scss变量插值,编译后为.el-button @content; &#125;&#125;&#x2F;&#x2F; @content&#96;用在mixin里面的，当定义一个mixin后，并且设置了@content&#x2F;&#x2F; @include的时候可以传入相应的内容到mixin里面 @mixin e() 混入__ 12345678910111213141516171819202122232425262728293031323334@mixin e($element) &#123; /**假设$element为disabled **/ $E: $element !global; $selector: &amp;; // 父选择器 $currentSelector: \"\"; // 要生成的选择器 /** 遍历$element //可能有多个 /* $B 为 mixin b()混入中的变量名 /* 这里使用$B是因为在element组件样式中e的混入必定是在b混入下的 /* 如果是在el-button下使用e混入,则生成 .el-button__disabked **/ @each $unit in $element &#123; $currentSelector: #&#123;$currentSelector + \".\" + $B + $element-separator + $unit + \",\"&#125;; &#125; /** hitAllSpecialNestRule 判断$elector是否包含--, is-, 在function.scc 中定义 /* 这里判断是否包含is--,--是因为使用了 @at-root /* @at-root指令可以使一个或多个规则被限定输出在文档的根层级上，而不是被嵌套在其父选择器下 /* 包含有is--等前缀的样式名,在组件中一般是可移除的,所以在输出在文档的根层级上时要加上父选择器 **/ @if hitAllSpecialNestRule($selector) &#123; @at-root &#123; #&#123;$selector&#125; &#123; #&#123;$currentSelector&#125; &#123; @content; &#125; &#125; &#125; &#125; @else &#123; @at-root &#123; #&#123;$currentSelector&#125; &#123; @content; &#125; &#125; &#125;&#125; @mixin m() 混入– 123456789101112131415161718/** /* 该方法与混入e基本相同,不同的是没有判断hitAllSpecialNestRule/* 因为混入 -- 一般的是组件的尺寸样式,如 el-radio--medium,el-radio--small等,父选择器一般为el-radio等,/* 故不需要判断**/@mixin m($modifier) &#123; $selector: &amp;; $currentSelector: \"\"; @each $unit in $modifier &#123; $currentSelector: #&#123;$currentSelector + &amp; + $modifier-separator + $unit + \",\"&#125;; &#125; @at-root &#123; #&#123;$currentSelector&#125; &#123; @content; &#125; &#125;&#125; @mixin w() 混入 is 12345678910/** 假设$state为check/* 则编译后为在文档的根层级(在组件中使用时,为组件根样式)为.el-radio.is-checked**/@mixin when($state) &#123; @at-root &#123; &amp;.#&#123;$state-prefix + $state&#125; &#123; @content; &#125; &#125;&#125; functon.scssfunction.scss 主要是定义了 hitAllSpecialNestRule 函数方法，主要用来对选择器是否含有’is-‘, ‘–’, ‘:’主要代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@import \"config\";/* BEM support Func -------------------------- */@function selectorToString($selector) &#123; //字符化 $selector: inspect($selector); /** str-slice /* 从 $string 中截取子字符串，通过 $start-at 和 $end-at /* 设置始末位置，未指定结束索引值则默认截取到字符串末尾。 /* 这里主要是去除第一个字符和最后一个字符,避免如 --el, el：等的干扰 **/ $selector: str-slice($selector, 2, -2); @return $selector;&#125;@function containsModifier($selector) &#123; $selector: selectorToString($selector); /** str-index($string, $substring) /* 返回一个下标，标示 $substring 在 $string 中的起始位置。没有找到的话，则返回 null 值。 /* $modifier-specarator -- **/ @if str-index($selector, $modifier-separator) &#123; @return true; &#125; @else &#123; @return false; &#125;&#125;@function containWhenFlag($selector) &#123; $selector: selectorToString($selector);/** $state-prefix: 'is-'; **/ @if str-index($selector, '.' + $state-prefix) &#123; @return true &#125; @else &#123; @return false &#125;&#125;@function containPseudoClass($selector) &#123; $selector: selectorToString($selector); @if str-index($selector, ':') &#123; @return true &#125; @else &#123; @return false &#125;&#125;//** 对上述四种情况进行判断，有一种存在就返回true **/@function hitAllSpecialNestRule($selector) &#123; @return containsModifier($selector) or containWhenFlag($selector) or containPseudoClass($selector);&#125;","categories":[{"name":"源码学习","slug":"源码学习","permalink":"http://lizehongss.github.io/newBlog/categories/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"element","slug":"element","permalink":"http://lizehongss.github.io/newBlog/tags/element/"}]},{"title":"css布局","slug":"CSS布局","date":"2018-06-23T00:00:00.000Z","updated":"2020-07-25T12:35:54.160Z","comments":true,"path":"2018/06/23/CSS布局/","link":"","permalink":"http://lizehongss.github.io/newBlog/2018/06/23/CSS%E5%B8%83%E5%B1%80/","excerpt":"","text":"css布局（持续更新）将浮动元素围住 为父元素添加 overflow:hidden 属性演示如下： 同时浮动父元素 为父元素添加float:left演示如下： 添加非浮动元素的清除元素 代码如下 1234567.clear:after&#123; content:&quot;.&quot;; display:block; height:0; visibility:hidden; clear:both;&#125; 三栏一固定宽度布局 父元素wrapper 设定一固定宽度，水平外边距为auto 子元素nav和artice设置浮动，宽度相加为wrapper的宽度（再加以此类推） header和footer 默认与布局同宽 footer要清除浮动html代码如下： 1234567&lt;div id&#x3D;&quot;wrapper&quot;&gt;&lt;header&gt;&lt;!-- 标题 --&gt;header&lt;&#x2F;header&gt;&lt;nav&gt;&lt;!-- 无序列表 -- nav&lt;&#x2F;nav&gt;&lt;article&gt;&lt;! -- 文本 --&gt; article&lt;&#x2F;article&gt;&lt;aside&gt;&lt;! -- 文本 --&gt;aside&lt;&#x2F;aside&gt;&lt;footer&gt;&lt;!-- 文本 --&gt; footer&lt;&#x2F;footer&gt; css代码如下： 1234567891011121314151617181920212223242526#wrapper&#123; margin: 0 auto; width:960px; height:700px;&#125;header&#123; background:#dcd9c0; height:30px;&#125;nav&#123; width:150px; float:left; background:#dcd9c0; height:400px;&#125; article&#123; width:600px; float:left; background:#ffed53; height:400px;&#125;aside&#123; width:210px; float:left; background:#3f7ccf; height:400px;&#125;footer&#123; clear:both; background:#000; height:40px;&#125; 各栏边界分开的解决方法： 为子元素里的内容加一个div,为div设置一个内边距 为浮动栏设置 box-sizing:border-box 以及内边距和边框即可– IE7和IE8不支持 三栏–中栏流动布局 方法一 用一个div class为threecolarap 包围全部三栏并为其设置浮动 用一个div class为twocolarap包围左栏和中栏并为其设置浮动以及加上 margin-right:210px 把右栏拉到区块外边距腾出的位置上 中栏加上 margin-right:210px 在流动居中的栏右测腾出空间 方法二 为每一栏display属性设定为table-cell (IE7不支持)补充元素居中 为父元素应用 text-algin:center 为要居中的元素设定 display:inline-block","categories":[{"name":"css","slug":"css","permalink":"http://lizehongss.github.io/newBlog/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://lizehongss.github.io/newBlog/tags/css/"}]},{"title":"js算法3","slug":"算法3","date":"2018-03-31T00:00:00.000Z","updated":"2020-07-25T12:35:54.160Z","comments":true,"path":"2018/03/31/算法3/","link":"","permalink":"http://lizehongss.github.io/newBlog/2018/03/31/%E7%AE%97%E6%B3%953/","excerpt":"","text":"要求介绍 个人代码： 12345678910111213function encode(str, n)&#123; var arr &#x3D;[]; var j&#x3D;0; var n &#x3D; n.toString().split(&#39;&#39;).map(Number); for(var i &#x3D;0;i&lt;str.length;i++)&#123; arr.push((str[i].charCodeAt()-96)); arr[i]&#x3D;arr[i]+n[j]; j++; if(j&#x3D;&#x3D;n.length) j&#x3D;0; &#125; return arr;&#125; 别人代码 1234function encode(str, n) &#123; const key &#x3D; String(n) return Array.from(str, (c, i) &#x3D;&gt; c.charCodeAt(0) - 96 + Number(key[i % key.length]))&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://lizehongss.github.io/newBlog/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://lizehongss.github.io/newBlog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"js算法1","slug":"算法1","date":"2018-03-23T00:00:00.000Z","updated":"2020-07-25T12:35:54.160Z","comments":true,"path":"2018/03/23/算法1/","link":"","permalink":"http://lizehongss.github.io/newBlog/2018/03/23/%E7%AE%97%E6%B3%951/","excerpt":"","text":"js相关算法 传入四个正整数参数，返回最小的两个，代码如下：12345678910function sumTwoSmallestNumbers(numbers) &#123; var min&#x3D;Math.min.apply(Math,numbers); var filterResult&#x3D; numbers.filter((item)&#x3D;&gt;&#123; return (item!&#x3D;min) &#125; ) var smin&#x3D;Math.min.apply(Math,filterResult); return min+smin; &#x2F;&#x2F;Code here&#125;; 最优解(别人代码系列)12345function sumTwoSmallestNumbers(numbers)&#123; numbers &#x3D; numbers.sort(function(a, b)&#123;return a - b; &#125;); return numbers[0] + numbers[1];&#125;;&#x2F;&#x2F;使用排序解决。。。。 给定一个正整数n写成abcd …（a，b，c，d…是数字）和一个正整数p，我们想要找到一个正整数k，如果存在的话，比如数字的总和对于p的连续幂的n等于k * n。换一种说法：例如：（a ^ p + b ^（p + 1）+ c ^（p + 2）+ d ^（p + 3）+ …）= n * k如果是这种情况，我们将返回K，如果不返回-1。注：N，P将始终作为严格正整数给出。代码如下：1234567891011function digPow(n, p)&#123; &#x2F;&#x2F; ... var s&#x3D;n.toString(); var sum &#x3D;0; for(var i&#x3D;0;i&lt;s.length;i++)&#123; sum+&#x3D;Math.pow(s[i],p); p++; &#125; if(sum%n&#x3D;&#x3D;0) return sum&#x2F;n; else return -1;&#125; 最优解(别人代码系列)12345678function digPow(n, p) &#123; var x &#x3D; String(n).split(&quot;&quot;).reduce((s, d, i) &#x3D;&gt; s + Math.pow(d, p + i), 0) return x % n ? -1 : x &#x2F; n&#125;&#x2F;&#x2F;reduce中s为上一次调用回调函数时的返回值，或者初始值&#x2F;&#x2F;d为当前正在处理的数组元素&#x2F;&#x2F;i为当前数组元素下标&#x2F;&#x2F;初始值为0 找到n下面所有倍数的总和m，例子： sumMul(2, 9) ==&gt; 2 + 4 + 6 + 8 = 20 sumMul(3, 13) ==&gt; 3 + 6 + 9 + 12 = 30 sumMul(4, 123) ==&gt; 4 + 8 + 12 + … = 1860 sumMul(4, -7) ==&gt; “INVALID”代码如下： 12345678910111213function sumMul(n,m)&#123;&#x2F;&#x2F;your idea herevar sum&#x3D;0;var double&#x3D;1;var val&#x3D;n;while(val&lt;m)&#123;sum+&#x3D;val;double++;val&#x3D;n*double;&#125;if(sum&#x3D;&#x3D;0) return &quot;INVALID&quot;;return sum;&#125; 别人代码 123456789function sumMul(n,m)&#123; if (n &gt;&#x3D; m) return &quot;INVALID&quot;;var sum &#x3D; 0; for (var i &#x3D; n; i &lt; m; i+&#x3D;n) &#123; sum +&#x3D; i; &#125; return sum;&#125; 公差公式，示例如下： arithmetic_sequence_elements(1, 2, 5) == “1, 3, 5, 7, 9”代码如下：1234567891011121314function arithmeticSequenceElements(a,r,n) &#123; &#x2F;&#x2F;your code here var arr &#x3D;[]; var i&#x3D;0; while(arr.length&lt;n)&#123; if(i&#x3D;&#x3D;0)&#123; arr[i]&#x3D;a&#125; else arr[i]&#x3D;&#39; &#39;+a; a&#x3D;a+r; i++; &#125; arr&#x3D;arr.toString(); return arr;&#125; 别人代码系列:12345function arithmeticSequenceElements(a,r,n) &#123; var ret &#x3D; [a] while (--n) ret.push(a+&#x3D;r); return ret.join(&#39;, &#39;)&#125; 去除！示例如下： remove(“Hi!”) == “Hi!” remove(“Hi!!!”) == “Hi!!!” remove(“!Hi”) == “Hi” remove(“!Hi!”) == “Hi!” remove(“Hi! Hi!”) == “Hi Hi!” remove(“Hi”) == “Hi” 代码如下： 123456function remove(s)&#123; &#x2F;&#x2F;coding and coding.... var a&#x3D;&#x2F;!+[^!$]&#x2F;gm; return s.replace(a,&quot; &quot;);&#125;&#x2F;&#x2F;自己的想法，然后有两个没过。 别人代码系列： 12345function remove(s)&#123; var a&#x3D;&#x2F;!+(?!!*$)&#x2F;g; return s.replace(a, &#39;&#39;);&#125;总体思路是对，不匹配最后的！用零宽负向先行断言，要求接下来的字符不与!匹配 返回最大和最小，示例如下： highAndLow(“1 2 3 4 5”); // return “5 1” highAndLow(“1 2 -3 4 5”); // return “5 -3” highAndLow(“1 9 3 4 -5”); // return “9 -5” 代码如下： 123456789101112function highAndLow(numbers)&#123; &#x2F;&#x2F; ... var arr &#x3D;numbers.split(&#x2F;[\\ ]+&#x2F;); var arr&#x3D;arr.map(function(item)&#123; return parseInt(item); &#125;) var max&#x3D;Math.max.apply(Math,arr); var min&#x3D;Math.min.apply(Math,arr); console.log(max); return max.toString()+&quot; &quot;+min.toString(); &#125; 别人代码 ： 1234function highAndLow(numbers)&#123; numbers &#x3D; numbers.split(&#39; &#39;).map(Number); return Math.max.apply(0, numbers) + &#39; &#39; + Math.min.apply(0, numbers);&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://lizehongss.github.io/newBlog/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://lizehongss.github.io/newBlog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"js算法2","slug":"算法2","date":"2018-03-23T00:00:00.000Z","updated":"2020-07-25T12:35:54.160Z","comments":true,"path":"2018/03/23/算法2/","link":"","permalink":"http://lizehongss.github.io/newBlog/2018/03/23/%E7%AE%97%E6%B3%952/","excerpt":"","text":"首字母大写 代码如下 ： 123456789function capitalizeWord(word) &#123; var r &#x3D;word.charAt(0); var s&#x3D;r.toUpperCase();var arr&#x3D;word.split(&#39;&#39;); arr[0]&#x3D;s; var arrs&#x3D;arr.toString().replace(&#x2F;,&#x2F;g , &quot;&quot;); return arrs;&#125; 别人代码： 1234function capitalizeWord(word) &#123; return word[0].toUpperCase() + word.slice(1); &#x2F;&#x2F;删除第一个字母&#125; 计算体积并得出差值代码如下：12345678910111213141516171819function findDifference(a, b) &#123; &#x2F;&#x2F;loading... var s1&#x3D;1,s2&#x3D;1; for(var i&#x3D;0;i&lt;a.length;i++)&#123; s1&#x3D;s1*a[i]; &#125; for(var i&#x3D;0;i&lt;b.length;i++)&#123; s2&#x3D;s2*b[i]; &#125; if(s1&gt;s2)&#123; return s1-s2; &#125; if(s1&lt;s2)&#123; return s2-s1; &#125; if(s1&#x3D;&#x3D;s2)&#123; return 0; &#125;&#125; 别人代码如下： 123function find_difference(a, b) &#123; return Math.abs(a.reduce((previous, current) &#x3D;&gt; previous * current) - b.reduce((previous, current) &#x3D;&gt; previous * current));&#125; 返回数组中不重复的值代码如下:123456function stray(numbers)&#123; for (var i in numbers)&#123; if (numbers.indexOf(numbers[i]) &#x3D;&#x3D;&#x3D; numbers.lastIndexOf(numbers[i]))&#123;return numbers[i]&#125; &#125;&#125;&#x2F;&#x2F;向前和向后搜索，如果索引相同说明只有一个，可以返回 转换Number类型示例如下：348597 =&gt; [7,9,5,8,4,3]代码如下：12345678function digitize(n) &#123; var s&#x3D;n.toString(); var arr&#x3D;[]; for(var i&#x3D;0;i&lt;s.length;i++)&#123; arr.push(s[i]); &#125; return arr.map(Number).reverse();&#125; 别人代码系列123function digitize(n)&#123; return (n + &#39;&#39;).split(&#39;&#39;).map(Number).reverse();&#125; solution(‘world’); // returns ‘dlrow’ 代码如下： 123var arr &#x3D;str.split(&#39;&#39;); arr&#x3D;arr.sort().toString().replace(&#x2F;,&#x2F;g,&#39;&#39;); return arr; 别人代码： 123function solution(str)&#123; return str.split(&#39;&#39;).reverse().join(&#39;&#39;); &#125; 简单的运算 代码如下： 1234567891011121314function basicOp(operation, value1, value2) &#123; switch (operation) &#123; case &#39;+&#39;: return value1 + value2; case &#39;-&#39;: return value1 - value2; case &#39;*&#39;: return value1 * value2; case &#39;&#x2F;&#39;: return value1 &#x2F; value2; default: return 0; &#125;&#125; 别人代码： 1234function basicOp(o, a, b) &#123; return eval(a+o+b);&#125;&#x2F;&#x2F;eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。","categories":[{"name":"算法","slug":"算法","permalink":"http://lizehongss.github.io/newBlog/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://lizehongss.github.io/newBlog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"面试2","slug":"面试2","date":"2018-03-23T00:00:00.000Z","updated":"2020-07-25T12:35:54.160Z","comments":true,"path":"2018/03/23/面试2/","link":"","permalink":"http://lizehongss.github.io/newBlog/2018/03/23/%E9%9D%A2%E8%AF%952/","excerpt":"","text":"浏览器如何解析css CSS选择器的解析是从右向左解析的。若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 Render Tree。 数组和对象的原生方法数组方法有 转换方法：toLocaleString(),toString(),valueOf() 栈方法：push(),pop() 队列方法 shift(),unshif() 重排序方法 reverse() ,sort() 操作方法 concat() slice() splice() 位置方法 indexOf() lastIndexOf() 迭代方法 ecery() filter() fotEach() map() some() 归并方法 reduce() reduceRight() 如果需要手动写动画，你认为最小时间间隔是多久，为什么？ 多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms。 作用域问题(专开坑) js数据类型并写出它们的内存图 js数据类型：Undefined Null Boolean Number String Object JS中的基础数据类型，这些值都有固定的大小，往往都保存在栈内存中，由系统自动分配存储空间。我们可以直接操作保存在栈内存空间的值 jS的引用数据类型，比如数组Array，它们值的大小是不固定的。引用数据类型的值是保存在堆内存中的对象。 null和undefine的区别 答案 为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式 父元素的高度无法被撑开，影响与父元素同级的元素 与浮动元素同级的非浮动元素（内联元素）会跟随其后 若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构。方法： 父级div定义height 最后一个浮动元素后加空div标签 并添加样式clear:both。 包含浮动元素的父标签添加样式overflow为hidden或auto。 父级div定义zoom :after和::after有什么区别，有什么作用 作用 使得html更加语义化。有些时候，为了某些特定的展现，不得不添加用于辅助布局的无意义html元素，这两个伪元素能实际起到这种辅助布局的作用，而又不增加无意义纯布局html元素，所以html就更简洁更纯粹了。 区别before/:after这种写法css2中就有，叫伪类；::befroe/::after这种写法是css3中的，叫伪元素，但两种写法的作用是一样的。后者无法兼容IE低版本，如果要求兼容IE低版本请使用前者。注：对于img和input元素两者都不起作用","categories":[{"name":"面试","slug":"面试","permalink":"http://lizehongss.github.io/newBlog/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://lizehongss.github.io/newBlog/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"面试3","slug":"面试3","date":"2018-03-23T00:00:00.000Z","updated":"2020-07-25T12:35:54.160Z","comments":true,"path":"2018/03/23/面试3/","link":"","permalink":"http://lizehongss.github.io/newBlog/2018/03/23/%E9%9D%A2%E8%AF%953/","excerpt":"","text":"vue 生命周期 beforecreated：el 和 data 并未初始化 created:完成了 data 数据的初始化，el没有 beforeMount：完成了 el 和 data 初始化 mounted ：完成挂载 beforecreate : 举个栗子：可以在这加个loading事件 created ：在这结束loading，还做一些初始化，实现函数自执行 mounted ： 在这发起后端请求，拿回数据，配合路由钩子做一些事情 beforeDestroy： 你确认删除XX吗？ destroyed ：当前组件已被删除，清空相关内容 组件通信 父组件向子组件通信 使用props即可 子组件向父组件通信 使用自定义事件，子组件用$emit()来触发向父组件通信的事件 非父子组件通信 在vue.js2.x中使用一个空的vu实例来作中介，组件把自定义事件名称和数据发送到这个空实例，其它实例或组件通过监听空实例的自定义事件来刷新数据 网络状态 1XX 成功 2XX 重定向 3XX 客户机中出现的错误 400 请求无效 闭包应用场景 闭包通常用来创建内部变量，使得这些变量不能被外部随意修改，同时又可以通过指定的函数接口来操作。","categories":[{"name":"面试","slug":"面试","permalink":"http://lizehongss.github.io/newBlog/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://lizehongss.github.io/newBlog/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"面试1","slug":"面试1","date":"2018-03-22T00:00:00.000Z","updated":"2020-07-25T12:35:54.160Z","comments":true,"path":"2018/03/22/面试1/","link":"","permalink":"http://lizehongss.github.io/newBlog/2018/03/22/%E9%9D%A2%E8%AF%951/","excerpt":"","text":"清除浮动方法1：:after方法123456:after&#123; content: &quot;.&quot;; clean：both;display:block;height: 0px;&#125; 方法2：父元素设置overflow:hidden1234.f&#123; overflow:hidden; &#125; 方法3：添加空div标签clean:both123.clean-both&#123; clean:both;&#125; div垂直和水平居中方法1 使用absolute+transform123456789.parent&#123; position: relative;&#125;.child&#123; position:absolute; left:50%; top:50%; transform:tranplate(-50%,-50%);&#125; 方法2 inline-block+text-align12345678.parent&#123; text-align:center; display:table-cell; vertical-align:middle;&#125;.child&#123; display:inline-block;&#125; 方法3 flex12345.parent&#123; display:flex; justify-content:center; align-items:center;&#125; DOM操作获取子元素并插入1234&lt;ul&gt;&lt;li&gt;1&lt;&#x2F;li&gt;&lt;li&gt;3&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt; 代码如下：12345var li&#x3D;document.createElement(&quot;li&quot;);var textNode&#x3D;document.createTextNode(&quot;2&quot;);li.appendChild(textNode);var ul&#x3D;document.getElementsByTagName(&quot;ul&quot;);ul.insertBefore(li,ul.childNodes[1]); 数组去重遍历，将数组的值添加到一个对象的属性名里，并给属性赋值，对象不能添加相同属性名，以这个为依据可以实现数组去重，然后用Object.keys(对象)返回这个对象可枚举属性组成的数组，这个数组就是去重后的数组。1234567891011121314 let a &#x3D; [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, 1,NaN,NaN,undefined,undefined,null,null, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;]; const unique &#x3D; arr &#x3D;&gt; &#123; var obj &#x3D; &#123;&#125; arr.forEach(value &#x3D;&gt; &#123; obj[value] &#x3D; 0;&#x2F;&#x2F;这步新添加一个属性，并赋值，如果不赋值的话，属性会添加不上去 &#125;) return Object.keys(obj);&#x2F;&#x2F;&#96;Object.keys(对象)&#96;返回这个对象可枚举属性组成的数组，这个数组就是去重后的数组 &#125; console.log(unique(a));&#x2F;&#x2F;[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;NaN&quot;, &quot;undefined&quot;, &quot;null&quot;, &quot;a&quot;, &quot;b&quot;]作者：OBKoro1链接：https:&#x2F;&#x2F;juejin.im&#x2F;post&#x2F;5aad40e4f265da237f1e12ed来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 es6123let unique&#x3D; [...new Set(array)];&#x2F;&#x2F;es6 Set数据结构类似于数组，成员值是唯一的，有重复的值会自动去重。&#x2F;&#x2F;Set内部使用&#x3D;&#x3D;&#x3D;来判断是否相等，类似&#39;1&#39;和1会两个都保存，NaN和NaN只会保存一个 提高页面加载速度 减少dom操作 部署前，图片压缩，代码压缩 优化js代码结构，减少冗余代码 减少http请求，合理设置 HTTP缓存 使用内容分发cdn加速 静态资源缓存 图片延迟加载 作用域问题1234567891011121314151617181920212223function F()&#123; var arr&#x3D;[],i; for(i&#x3D;0;i&lt;3;i++)&#123; arr[i]&#x3D;function()&#123; return i; &#125;; &#125; return arr ;&#125;结果都为3;闭包问题方法为function F()&#123; function binder(x)&#123; return function()&#123; return x; &#125;; &#125; var arr &#x3D;[],i; for(i&#x3D;0;i&lt;3;i++)&#123; arr[i]&#x3D;binder(i); &#125; return arr;&#125; vue数据监控 使用watch监控 使用计算属性 过渡器","categories":[{"name":"面试","slug":"面试","permalink":"http://lizehongss.github.io/newBlog/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://lizehongss.github.io/newBlog/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"vue学习笔记(二)————组件","slug":"vue学习笔记-组件 ","date":"2018-02-10T00:00:00.000Z","updated":"2020-07-25T12:35:54.160Z","comments":true,"path":"2018/02/10/vue学习笔记-组件 /","link":"","permalink":"http://lizehongss.github.io/newBlog/2018/02/10/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BB%84%E4%BB%B6%20/","excerpt":"","text":"前言主要是有关vue组件的笔记，然后也不想为了定blog而写blog,所以应该会写一些真的自己想记下来的东西，也希望可以尽量精简的写 组件用法需要注册才能使用组件，注册分为局部注册和全局注册，代码示例如下： 必须在实例注册，组件才可以使用 123456789101112&#x2F;&#x2F;全局注册Vue.component(&quot;组件名&quot;,&#123; &#x2F;&#x2F;选项 &#125;);&#x2F;&#x2F;局部注册var 组件名 &#x3D;&#123; &#x2F;&#x2F;选项&#125;html模板如下：&lt;组件名&gt;&lt;&#x2F;组件名 组件选项templatetemlplate后面是要渲染的内容，必须有一个元素包围它，代码如下： 注意v-show不能用在template中，可以使用v-if 1234Vue.component(&quot;组件名&quot;,&#123;template: &#39;&lt;div&gt;&lt;&#x2F;div&gt;&#39;; &#125;); datadata的用法与实方法相同，不同的是要将数据return出去，代码如下： 12345678910Vue.component(&quot;组件名&quot;,&#123;.....data : function&#123; return &#123; mws: &quot;text&quot; &#125;&#125; &#125;); propsprops主要是用来接收来自父组件的数据，可以是字符串数组和对象注意数据是单向的，只能父组件传到子组件代码如下： 123456789html:&lt;mytext message&#x3D;&quot;text&quot;&gt;&lt;&#x2F;mytext&gt;js：Vue.component(&quot;mytext&quot;,&#123; props:[&#39;message&#39;] &#125;); props的数据可以进行验证，代码如下： 12345678props: &#123; message : &#123; type:Number， &#x2F;&#x2F;类型 default:&quot;&quot;text &#x2F;&#x2F;如果没有定义的默认值 &#125; &#125;&#125; wath 主要是用来监听props的值的改变，从而通知父组件或者更新props值 代码如下 123456watch:&#123; message: function(val)&#123; &#x2F;&#x2F;当message发生改变时触发的函数 &#x2F;&#x2F;val 为更新后的message值 &#125;&#125; 组件通信父组件向子组件通信使用上面的props即可 子组件向父组件通信使用自定义事件，子组件用$emit()来触发向父组件通信的事件代码如下： 12345678910111213html:&lt;mytext @send&#x3D;&quot;handle&quot;&gt;&lt;&#x2F;mytext&gt;&#x2F;&#x2F;其中send为子组件发送过来的参数，为自定义事件的名称Vue.component(&quot;mytext&quot;,&#123;template:&#39;&lt;button @click&#x3D;&quot;hadles&quot;&gt;&#39;,methods:&#123; hadles: function()&#123; this.$emit(&#39;handle&#39;,数据); &#x2F;&#x2F;第一个参数为事件名称，第二个为发送的数据 &#125;&#125; &#125;); 可以使用v-model来简化，不过个人感觉没有必要，所以不想写在这里做总结。。。。。。 非父子组件通信在vue.js2.x中使用一个空的vu实例来作中介，组件把自定义事件名称和数据发送到这个空实例，其它实例或组件通过监听空实例的自定义事件来刷新数据代码如下： 123var bus &#x3D;new Vue();bus.$emit(&#39;clicks&#39;,mes);bus.$on(&#39;clicks&#39;,function()&#123;&#125;); 补充：当子组件较多时，可以用ref属性为组件指定一个索引名称：代码如下: 1234html代码如下：&lt;mytext ref&#x3D;&quot;A&gt;&lt;&#x2F;mytext&gt;&#x2F;&#x2F;调用指定的子组件的messagevar msg&#x3D;this.$refs.comA.message slotslot是内容分发，用在将父组件的dom结构挂载，它与props,events触发事件构成组件的3个APi来源.slot的作用域是在父组件上代码如下： 12345678910111213&lt;mytext&gt;&lt;p&gt;&lt;&#x2F;p&gt;&#x2F;&#x2F;挂载内容 &lt;&#x2F;mytext&gt;Vue.component(&quot;mytext&quot;,&#123;template:&#39; &lt;div&gt; &lt;slot&gt; &lt;p&gt;&lt;&#x2F;p&gt;&#x2F;&#x2F;没有内容时的默认内容 &lt;&#x2F;slot&gt;&#x2F;&#x2F;父组件的内容将挂载在slot里面 &lt;&#x2F;div&gt;&#39; &#125;); 可以给slot指定一个name，使用分发指定内容代码如下： 123456789101112&lt;mytext&gt;&lt;p slot&#x3D;&quot;one&quot;&gt;&lt;&#x2F;p&gt;&#x2F;&#x2F;挂载内容,slot为具名slot&lt;&#x2F;mytext&gt;Vue.component(&quot;mytext&quot;,&#123;template:&#39; &lt;div&gt; &lt;slot&gt; &lt;p&gt;&lt;&#x2F;p&gt;&#x2F;&#x2F;没有内容时的默认内容 &lt;&#x2F;slot&gt;&#x2F;&#x2F;父组件的内容将挂载在slot里面 &lt;slot name&#x3D;&quot;one&quot;&gt;&#x2F;&#x2F;具名slot将分发在这里 &lt;&#x2F;div&gt;&#39; 也可以指定数据传递到父组件的挂载里，使用scope,代码如下： 123456789101112131415&lt;mytext&gt;&lt;p slot&#x3D;&quot;one&quot; scope&#x3D;&quot;props&quot;&gt; &#123;&#123;props.msg&#125;&#125; &#x2F;&#x2F;显示子组件的msg&lt;&#x2F;p&gt;&#x2F;&#x2F;挂载内容,slot为具名slot,props为临时变量&lt;&#x2F;mytext&gt;Vue.component(&quot;mytext&quot;,&#123;template:&#39; &lt;div&gt; &lt;slot&gt; &lt;p&gt;&lt;&#x2F;p&gt;&#x2F;&#x2F;没有内容时的默认内容 &lt;&#x2F;slot&gt;&#x2F;&#x2F;父组件的内容将挂载在slot里面 &lt;slot name&#x3D;&quot;one&quot; msg&#x3D;&quot;数据&quot;&gt;&#x2F;&#x2F;具名slot将分发在这里 &#x2F;&#x2F;msg为向父组件传递的数据 &lt;&#x2F;div&gt;&#39; 可以使用$slots访问分发的内容 1var header &#x3D;this.$slots.one; 结语还有许多关于组件的高级用法，不过我不是大佬，等以后用到再写吧。写完收工睡觉","categories":[{"name":"vue","slug":"vue","permalink":"http://lizehongss.github.io/newBlog/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://lizehongss.github.io/newBlog/tags/vue/"}]},{"title":"vue学习笔记(一)————基础知识","slug":"vue学习笔记-基础知识","date":"2018-02-06T00:00:00.000Z","updated":"2020-07-25T12:35:54.160Z","comments":true,"path":"2018/02/06/vue学习笔记-基础知识/","link":"","permalink":"http://lizehongss.github.io/newBlog/2018/02/06/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"前言学习vue的笔记，应该会试着写一个系列，目的还是加深印象，毕竟感觉自己的记忆力真的不ok,也是给自己的学习留下一点东西 创建vue实例和数据12345678var app &#x3D; new Vue(&#123; el:&#39;#app&#39;，&#x2F;&#x2F;指定挂载vue实例的元素，一般为id data:&#123; &#x2F;&#x2F;数据 a:1 &#125; &#125;) 在html中使用来显示数据， 是双向绑定的 生命周期vue 常用的生命周期钩子为 语法 | 简介 ——— | ————created | 实例创建完成后调用mounted | el挂载到实例上后调用beforeDestroy | 实例销毁之前调用 用法示例： 1234567891011ar app &#x3D; new Vue(&#123; el:&#39;#app&#39;，&#x2F;&#x2F;指定挂载vue实例的元素，一般为id data:&#123; &#x2F;&#x2F;数据 a:1 &#125; created: function()&#123; &#x2F;&#x2F;函数 &#125; &#125;) 过滤器 过滤器应该写在filters中,主要对数据进行过滤，如格式化文本，字母全部大写 12345678910ar app &#x3D; new Vue(&#123; el:&#39;#app&#39;, data:&#123; &#125; filters:&#123; b: function ()&#123; &#x2F;&#x2F;函数 &#125; &#125; &#125;) html中写法为： 1&#123;&#123;a|b&#125;&#125; 过滤器也可以串联接收数据 1&#123;&#123;a|b|c&#125;&#125; #计算属性计算属性应该写在computed中，应用在过长的逻辑运算 123456789&#123;&#123;d&#125;&#125;ar app &#x3D; new Vue(&#123; .... computed: d:function()&#123; return &#x2F;&#x2F;返回结果 &#125; &#125;) 注意: 计算属性不仅可以依赖当前Vue实例的数据，也可以依赖其它实例的数据 计算属性是基于它的依赖缓存的，只要数据不改变，计算属性不更新 基本指令v-bind动态更新HTML元素上的属性 123456789&lt;a v-bind:href&#x3D;&quot;url&quot;&gt;&lt;&#x2F;a&gt;ar app &#x3D; new Vue(&#123; ... data:&#123; url:... &#125; &#125;) 语法糖为： 如 ：href=”url” v-on绑定事件监听器 1234567891011&lt;button v-on:click&#x3D;&quot;a&quot;&gt;&lt;&#x2F;button&gt;ar app &#x3D; new Vue(&#123; .... methods:&#123; a: function()&#123; &#x2F;&#x2F;函数 &#125; &#125; &#125;) 在供click调用的方法，可以不加括号，可用$event访问原生DON事件，如： 1v-on:click&#x3D;&quot;a(mes,$event)&quot; 语法糖为@ 如 @click=”a”在vue中提供修饰符来实现各种事件方法的绑定，其中包括 语法 | 简介 ——— | —————-@click.stop | 阻止事件冒泡@click.prevent| 提交事件不再重载页面@click.once | 只触发一次@keyup.13 | 监听键盘事件，键值为13 其中@keyup还提供其它键值的快捷名称，可在vue文档查找，如@keyup.down 其它指令语法 | 简介 ——— | —————-v-html | 输出htmlv-cloak | 在vue实例结束编译时从绑定的HTML元素上移除v-once | 定义它的元素或组件只渲染一次v-if v-eles-if v-else | 与if等相同，后加判断式v-show | 改变元素的CSS属性display，false时会隐藏v-for |与for类似，与in搭配使用","categories":[{"name":"vue","slug":"vue","permalink":"http://lizehongss.github.io/newBlog/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://lizehongss.github.io/newBlog/tags/vue/"}]}],"categories":[{"name":"源码学习","slug":"源码学习","permalink":"http://lizehongss.github.io/newBlog/categories/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"},{"name":"css","slug":"css","permalink":"http://lizehongss.github.io/newBlog/categories/css/"},{"name":"算法","slug":"算法","permalink":"http://lizehongss.github.io/newBlog/categories/%E7%AE%97%E6%B3%95/"},{"name":"面试","slug":"面试","permalink":"http://lizehongss.github.io/newBlog/categories/%E9%9D%A2%E8%AF%95/"},{"name":"vue","slug":"vue","permalink":"http://lizehongss.github.io/newBlog/categories/vue/"}],"tags":[{"name":"element","slug":"element","permalink":"http://lizehongss.github.io/newBlog/tags/element/"},{"name":"css","slug":"css","permalink":"http://lizehongss.github.io/newBlog/tags/css/"},{"name":"算法","slug":"算法","permalink":"http://lizehongss.github.io/newBlog/tags/%E7%AE%97%E6%B3%95/"},{"name":"面试","slug":"面试","permalink":"http://lizehongss.github.io/newBlog/tags/%E9%9D%A2%E8%AF%95/"},{"name":"vue","slug":"vue","permalink":"http://lizehongss.github.io/newBlog/tags/vue/"}]}